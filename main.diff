Common subdirectories: ../sqlite-2.8.17/src/CVS and src/CVS
diff -c ../sqlite-2.8.17/src/attach.c src/attach.c
*** ../sqlite-2.8.17/src/attach.c	2005-04-23 18:43:22.000000000 -0400
--- src/attach.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 85,90 ****
--- 85,91 ----
    sqliteHashInit(&aNew->tblHash, SQLITE_HASH_STRING, 0);
    sqliteHashInit(&aNew->idxHash, SQLITE_HASH_STRING, 0);
    sqliteHashInit(&aNew->trigHash, SQLITE_HASH_STRING, 0);
+   sqliteHashInit(&aNew->objectHash, SQLITE_HASH_STRING, 0);
    sqliteHashInit(&aNew->aFKey, SQLITE_HASH_STRING, 1);
    aNew->zName = zName;
    rc = sqliteBtreeFactory(db, zFile, 0, MAX_PAGES, &aNew->pBt);
diff -c ../sqlite-2.8.17/src/btree.c src/btree.c
*** ../sqlite-2.8.17/src/btree.c	2005-04-23 18:43:22.000000000 -0400
--- src/btree.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 361,367 ****
  ** MemPage.apCell[] of the entry.
  */
  struct BtCursor {
!   BtCursorOps *pOps;        /* Function table */
    Btree *pBt;               /* The Btree to which this cursor belongs */
    BtCursor *pNext, *pPrev;  /* Forms a linked list of all cursors */
    BtCursor *pShared;        /* Loop of cursors with the same root page */
--- 361,367 ----
  ** MemPage.apCell[] of the entry.
  */
  struct BtCursor {
!   BtCursorOps *pOps;        /* Function table */
    Btree *pBt;               /* The Btree to which this cursor belongs */
    BtCursor *pNext, *pPrev;  /* Forms a linked list of all cursors */
    BtCursor *pShared;        /* Loop of cursors with the same root page */
***************
*** 1805,1811 ****
      rc = sqlitepager_write(*ppPage);
    }
    return rc;
! }
  
  /*
  ** Add a page of the database file to the freelist.  Either pgno or
--- 1805,1811 ----
      rc = sqlitepager_write(*ppPage);
    }
    return rc;
! }
  
  /*
  ** Add a page of the database file to the freelist.  Either pgno or
***************
*** 2173,2179 ****
  ** is called recursively on the parent.
  **
  ** If this routine fails for any reason, it might leave the database
! ** in a corrupted state.  So if this routine fails, the database should
  ** be rolled back.
  */
  static int balance(Btree *pBt, MemPage *pPage, BtCursor *pCur){
--- 2173,2179 ----
  ** is called recursively on the parent.
  **
  ** If this routine fails for any reason, it might leave the database
! ** in a corrupted state.  So if this routine fails, the database should
  ** be rolled back.
  */
  static int balance(Btree *pBt, MemPage *pPage, BtCursor *pCur){
***************
*** 2753,2759 ****
          pCur->idx = 0;
          pCur->eSkip = SKIP_NEXT;
        }else{
!         pCur->eSkip = SKIP_PREV;
        }
      }else{
        pCur->eSkip = SKIP_NEXT;
--- 2753,2759 ----
          pCur->idx = 0;
          pCur->eSkip = SKIP_NEXT;
        }else{
!         pCur->eSkip = SKIP_PREV;
        }
      }else{
        pCur->eSkip = SKIP_NEXT;
***************
*** 3170,3176 ****
  ** Append a message to the error message string.
  */
  static void checkAppendMsg(IntegrityCk *pCheck, char *zMsg1, char *zMsg2){
!   if( pCheck->zErrMsg ){
      char *zOld = pCheck->zErrMsg;
      pCheck->zErrMsg = 0;
      sqliteSetString(&pCheck->zErrMsg, zOld, "\n", zMsg1, zMsg2, (char*)0);
--- 3170,3176 ----
  ** Append a message to the error message string.
  */
  static void checkAppendMsg(IntegrityCk *pCheck, char *zMsg1, char *zMsg2){
!   if( pCheck->zErrMsg ){
      char *zOld = pCheck->zErrMsg;
      pCheck->zErrMsg = 0;
      sqliteSetString(&pCheck->zErrMsg, zOld, "\n", zMsg1, zMsg2, (char*)0);
diff -c ../sqlite-2.8.17/src/btree_rb.c src/btree_rb.c
*** ../sqlite-2.8.17/src/btree_rb.c	2005-04-23 18:43:22.000000000 -0400
--- src/btree_rb.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 261,267 ****
   */
  static char *append_val(char * orig, char const * val){
    char *z;
!   if( !orig ){
      z = sqliteStrDup( val );
    } else{
      z = 0;
--- 261,267 ----
   */
  static char *append_val(char * orig, char const * val){
    char *z;
!   if( !orig ){
      z = sqliteStrDup( val );
    } else{
      z = 0;
***************
*** 554,560 ****
          pSib = pParent->pLeft;
        }
        if( !pSib ){
!         pX = pParent;
        }else if( 
            (!pSib->pLeft  || pSib->pLeft->isBlack) &&
            (!pSib->pRight || pSib->pRight->isBlack) ){
--- 554,560 ----
          pSib = pParent->pLeft;
        }
        if( !pSib ){
!         pX = pParent;
        }else if( 
            (!pSib->pLeft  || pSib->pLeft->isBlack) &&
            (!pSib->pRight || pSib->pRight->isBlack) ){
diff -c ../sqlite-2.8.17/src/build.c src/build.c
*** ../sqlite-2.8.17/src/build.c	2005-04-23 18:43:22.000000000 -0400
--- src/build.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 226,246 ****
    for(i=iDb; i<db->nDb; i++){
      Db *pDb = &db->aDb[i];
      temp1 = pDb->tblHash;
      temp2 = pDb->trigHash;
      sqliteHashInit(&pDb->trigHash, SQLITE_HASH_STRING, 0);
-     sqliteHashClear(&pDb->aFKey);
-     sqliteHashClear(&pDb->idxHash);
      for(pElem=sqliteHashFirst(&temp2); pElem; pElem=sqliteHashNext(pElem)){
        Trigger *pTrigger = sqliteHashData(pElem);
        sqliteDeleteTrigger(pTrigger);
      }
      sqliteHashClear(&temp2);
!     sqliteHashInit(&pDb->tblHash, SQLITE_HASH_STRING, 0);
!     for(pElem=sqliteHashFirst(&temp1); pElem; pElem=sqliteHashNext(pElem)){
!       Table *pTab = sqliteHashData(pElem);
!       sqliteDeleteTable(db, pTab);
      }
!     sqliteHashClear(&temp1);
      DbClearProperty(db, i, DB_SchemaLoaded);
      if( iDb>0 ) return;
    }
--- 226,253 ----
    for(i=iDb; i<db->nDb; i++){
      Db *pDb = &db->aDb[i];
      temp1 = pDb->tblHash;
+     sqliteHashInit(&pDb->tblHash, SQLITE_HASH_STRING, 0);
+     for(pElem=sqliteHashFirst(&temp1); pElem; pElem=sqliteHashNext(pElem)){
+       Table *pTab = sqliteHashData(pElem);
+       sqliteDeleteTable(db, pTab);
+     }
+     sqliteHashClear(&temp1);
+     sqliteHashClear(&pDb->idxHash);
      temp2 = pDb->trigHash;
      sqliteHashInit(&pDb->trigHash, SQLITE_HASH_STRING, 0);
      for(pElem=sqliteHashFirst(&temp2); pElem; pElem=sqliteHashNext(pElem)){
        Trigger *pTrigger = sqliteHashData(pElem);
        sqliteDeleteTrigger(pTrigger);
      }
      sqliteHashClear(&temp2);
!     temp2 = pDb->objectHash;
!     sqliteHashInit(&pDb->objectHash, SQLITE_HASH_STRING, 0);
!     for(pElem=sqliteHashFirst(&temp2); pElem; pElem=sqliteHashNext(pElem)){
!       Object *pObject = sqliteHashData(pElem);
!       sqliteDeleteObject(pObject);
      }
!     sqliteHashClear(&temp2);
!     sqliteHashClear(&pDb->aFKey);
      DbClearProperty(db, i, DB_SchemaLoaded);
      if( iDb>0 ) return;
    }
***************
*** 336,343 ****
    for(pFKey=pTable->pFKey; pFKey; pFKey=pNextFKey){
      pNextFKey = pFKey->pNextFrom;
      assert( pTable->iDb<db->nDb );
!     assert( sqliteHashFind(&db->aDb[pTable->iDb].aFKey,
!                            pFKey->zTo, strlen(pFKey->zTo)+1)!=pFKey );
      sqliteFree(pFKey);
    }
  
--- 343,350 ----
    for(pFKey=pTable->pFKey; pFKey; pFKey=pNextFKey){
      pNextFKey = pFKey->pNextFrom;
      assert( pTable->iDb<db->nDb );
! //    assert( sqliteHashFind(&db->aDb[pTable->iDb].aFKey,
! //                           pFKey->zTo, strlen(pFKey->zTo)+1)!=pFKey );
      sqliteFree(pFKey);
    }
  
***************
*** 969,988 ****
    if( pParse->explain==0 && pParse->nErr==0 ){
      Table *pOld;
      FKey *pFKey;
!     pOld = sqliteHashInsert(&db->aDb[p->iDb].tblHash, 
!                             p->zName, strlen(p->zName)+1, p);
!     if( pOld ){
!       assert( p==pOld );  /* Malloc must have failed inside HashInsert() */
!       return;
!     }
!     for(pFKey=p->pFKey; pFKey; pFKey=pFKey->pNextFrom){
!       int nTo = strlen(pFKey->zTo) + 1;
!       pFKey->pNextTo = sqliteHashFind(&db->aDb[p->iDb].aFKey, pFKey->zTo, nTo);
!       sqliteHashInsert(&db->aDb[p->iDb].aFKey, pFKey->zTo, nTo, pFKey);
!     }
!     pParse->pNewTable = 0;
!     db->nTable++;
!     db->flags |= SQLITE_InternChanges;
    }
  }
  
--- 976,1001 ----
    if( pParse->explain==0 && pParse->nErr==0 ){
      Table *pOld;
      FKey *pFKey;
! 
! 		if( db->aDb[p->iDb].aFKey.count>0 && db->init.busy==0) {
! 			db->flags |= SQLITE_InternChanges;
! 			sqliteResetInternalSchema(db, p->iDb);
! 		} else {
! 			pOld = sqliteHashInsert(&db->aDb[p->iDb].tblHash, 
! 															p->zName, strlen(p->zName)+1, p);
! 			if( pOld ){
! 				assert( p==pOld );  /* Malloc must have failed inside HashInsert() */
! 				return;
! 			}
! 			for(pFKey=p->pFKey; pFKey; pFKey=pFKey->pNextFrom){
! 				int nTo = strlen(pFKey->zTo) + 1;
! 				pFKey->pNextTo = sqliteHashFind(&db->aDb[p->iDb].aFKey, pFKey->zTo, nTo);
! 				sqliteHashInsert(&db->aDb[p->iDb].aFKey, pFKey->zTo, nTo, pFKey);
! 			}
! 			db->nTable++;
! 			db->flags |= SQLITE_InternChanges;
! 		}
! 		pParse->pNewTable = 0;
    }
  }
  
***************
*** 1178,1183 ****
--- 1191,1197 ----
    int base;
    sqlite *db = pParse->db;
    int iDb;
+ 	FKey *pFKey;
  
    if( pParse->nErr || sqlite_malloc_failed ) return;
    pTable = sqliteTableFromToken(pParse, pName);
***************
*** 1283,1296 ****
      sqliteEndWriteOperation(pParse);
    }
  
    /* Delete the in-memory description of the table.
    **
    ** Exception: if the SQL statement began with the EXPLAIN keyword,
    ** then no changes should be made.
    */
    if( !pParse->explain ){
!     sqliteUnlinkAndDeleteTable(db, pTable);
!     db->flags |= SQLITE_InternChanges;
    }
    sqliteViewResetAll(db, iDb);
  }
--- 1297,1316 ----
      sqliteEndWriteOperation(pParse);
    }
  
+ 
    /* Delete the in-memory description of the table.
    **
    ** Exception: if the SQL statement began with the EXPLAIN keyword,
    ** then no changes should be made.
    */
    if( !pParse->explain ){
!   	pFKey = sqliteHashFind(&db->aDb[iDb].aFKey, pTable->zName, strlen(pTable->zName)+1);
! 		if( pFKey ) {
! 		  sqliteSetString(&pParse->zWarning, "table ", pTable->zName,
! 			  " was target of foreign key constraints (now disabled)", (char*)0);
! 		}
! 		db->flags |= SQLITE_InternChanges;
! 		sqliteResetInternalSchema(db, iDb);
    }
    sqliteViewResetAll(db, iDb);
  }
***************
*** 1362,1367 ****
--- 1382,1391 ----
  
    assert( pTo!=0 );
    if( p==0 || pParse->nErr ) goto fk_end;
+ 	if( ((flags>>16)&0xff)!=OE_Restrict ) {
+       sqliteErrorMsg(pParse, "only 'on insert restrict' is supported");
+       goto fk_end;
+ 	}
    if( pFromCol==0 ){
      int iCol = p->nCol-1;
      if( iCol<0 ) goto fk_end;
***************
*** 1389,1395 ****
--- 1413,1421 ----
    pFKey = sqliteMalloc( nByte );
    if( pFKey==0 ) goto fk_end;
    pFKey->pFrom = p;
+ 	pFKey->nId = (p->pFKey) ? p->pFKey->nId+1 : 0;
    pFKey->pNextFrom = p->pFKey;
+   pFKey->pNextDef = pParse->db->pDeferredFKeys;
    z = (char*)&pFKey[1];
    pFKey->aCol = (struct sColMap*)z;
    z += sizeof(struct sColMap)*nCol;
***************
*** 1432,1440 ****
    pFKey->updateConf = (flags >> 8 ) & 0xff;
    pFKey->insertConf = (flags >> 16 ) & 0xff;
  
!   /* Link the foreign key to the table as the last step.
    */
!   p->pFKey = pFKey;
    pFKey = 0;
  
  fk_end:
--- 1458,1467 ----
    pFKey->updateConf = (flags >> 8 ) & 0xff;
    pFKey->insertConf = (flags >> 16 ) & 0xff;
  
!   /* Link the foreign key to the table as the last step and add to the
! 	** foreign key deferred DDL work list.
    */
!   pParse->db->pDeferredFKeys = p->pFKey = pFKey;
    pFKey = 0;
  
  fk_end:
***************
*** 2010,2016 ****
      sqliteExprDelete(pList->a[i].pOn);
      sqliteIdListDelete(pList->a[i].pUsing);
    }
!   sqliteFree(pList);
  }
  
  /*
--- 2037,2043 ----
      sqliteExprDelete(pList->a[i].pOn);
      sqliteIdListDelete(pList->a[i].pUsing);
    }
!   sqliteFree(pList);
  }
  
  /*
***************
*** 2087,2093 ****
    sqlite *db = pParse->db;
    Vdbe *v = sqliteGetVdbe(pParse);
    assert( iDb>=0 && iDb<db->nDb );
!   assert( db->aDb[iDb].pBt!=0 );
    if( iDb!=1 && !DbHasProperty(db, iDb, DB_Cookie) ){
      sqliteVdbeAddOp(v, OP_VerifyCookie, iDb, db->aDb[iDb].schema_cookie);
      DbSetProperty(db, iDb, DB_Cookie);
--- 2114,2120 ----
    sqlite *db = pParse->db;
    Vdbe *v = sqliteGetVdbe(pParse);
    assert( iDb>=0 && iDb<db->nDb );
!   assert( iDb==1 || db->aDb[iDb].pBt!=0 );
    if( iDb!=1 && !DbHasProperty(db, iDb, DB_Cookie) ){
      sqliteVdbeAddOp(v, OP_VerifyCookie, iDb, db->aDb[iDb].schema_cookie);
      DbSetProperty(db, iDb, DB_Cookie);
Only in src/: config.h
diff -c ../sqlite-2.8.17/src/date.c src/date.c
*** ../sqlite-2.8.17/src/date.c	2005-04-23 18:43:22.000000000 -0400
--- src/date.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 855,861 ****
       int nArg;
       int dataType;
       void (*xFunc)(sqlite_func*,int,const char**);
!   } aFuncs[] = {
      { "julianday", -1, SQLITE_NUMERIC, juliandayFunc   },
      { "date",      -1, SQLITE_TEXT,    dateFunc        },
      { "time",      -1, SQLITE_TEXT,    timeFunc        },
--- 855,861 ----
       int nArg;
       int dataType;
       void (*xFunc)(sqlite_func*,int,const char**);
!   } aFuncs[] = {
      { "julianday", -1, SQLITE_NUMERIC, juliandayFunc   },
      { "date",      -1, SQLITE_TEXT,    dateFunc        },
      { "time",      -1, SQLITE_TEXT,    timeFunc        },
diff -c ../sqlite-2.8.17/src/encode.c src/encode.c
*** ../sqlite-2.8.17/src/encode.c	2005-04-23 18:43:22.000000000 -0400
--- src/encode.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 215,221 ****
      nByteIn += n;
      nOut = sqlite_encode_binary(in, n, out);
      nByteOut += nOut;
!     if( nOut!=strlen(out) ){
        printf(" ERROR return value is %d instead of %d\n", nOut, strlen(out));
        exit(1);
      }
--- 215,221 ----
      nByteIn += n;
      nOut = sqlite_encode_binary(in, n, out);
      nByteOut += nOut;
!     if( nOut!=strlen(out) ){
        printf(" ERROR return value is %d instead of %d\n", nOut, strlen(out));
        exit(1);
      }
diff -c ../sqlite-2.8.17/src/expr.c src/expr.c
*** ../sqlite-2.8.17/src/expr.c	2005-04-23 18:43:22.000000000 -0400
--- src/expr.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 445,451 ****
    assert( zTab==0 || pEList==0 );
  
    pExpr->iTable = -1;
!   for(i=0; i<pSrcList->nSrc; i++){
      struct SrcList_item *pItem = &pSrcList->a[i];
      Table *pTab = pItem->pTab;
      Column *pCol;
--- 445,451 ----
    assert( zTab==0 || pEList==0 );
  
    pExpr->iTable = -1;
!   for(i=0; i<pSrcList->nSrc; i++){
      struct SrcList_item *pItem = &pSrcList->a[i];
      Table *pTab = pItem->pTab;
      Column *pCol;
***************
*** 563,568 ****
--- 563,580 ----
    }
  
    /*
+   ** cnt==0 means there was not match.  if we are parsing a
+   ** procedural block, check if it is a variable.
+   */
+   if( cnt==0 && pParse->pCurrentBlock ) {
+ 	assert( zDb==0 && zTab==0 );
+ 	if( sqliteLookupVar(pParse, pParse->pCurrentBlock, pExpr)==0 ) {
+       sqliteFree(zCol);
+       return 0;  
+ 	}
+   }
+ 
+   /*
    ** cnt==0 means there was not match.  cnt>1 means there were two or
    ** more matches.  Either way, we have an error.
    */
***************
*** 997,1002 ****
--- 1009,1020 ----
        return SQLITE_SO_TEXT;
      }
  
+ 	case TK_FOR:
+ 	case TK_ASSIGN:
+     case TK_VAR: {
+       return SQLITE_SO_TEXT;
+     }
+ 
      default:
        assert( p->op==TK_ABORT );  /* Can't Happen */
        break;
***************
*** 1065,1070 ****
--- 1083,1092 ----
        sqliteVdbeAddOp(v, OP_String, 0, 0);
        break;
      }
+     case TK_VAR: {
+       sqliteVdbeAddOp(v, OP_MemLoad, pExpr->iColumn, 0);
+       break;
+     }
      case TK_VARIABLE: {
        sqliteVdbeAddOp(v, OP_Variable, pExpr->iTable, 0);
        break;
diff -c ../sqlite-2.8.17/src/func.c src/func.c
*** ../sqlite-2.8.17/src/func.c	2005-04-23 18:43:22.000000000 -0400
--- src/func.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 30,36 ****
  */
  static void minmaxFunc(sqlite_func *context, int argc, const char **argv){
    const char *zBest; 
!   int i;
    int (*xCompare)(const char*, const char*);
    int mask;    /* 0 for min() or 0xffffffff for max() */
  
--- 30,36 ----
  */
  static void minmaxFunc(sqlite_func *context, int argc, const char **argv){
    const char *zBest; 
!   int i;
    int (*xCompare)(const char*, const char*);
    int mask;    /* 0 for min() or 0xffffffff for max() */
  
diff -c ../sqlite-2.8.17/src/hash.c src/hash.c
*** ../sqlite-2.8.17/src/hash.c	2005-04-23 18:43:22.000000000 -0400
--- src/hash.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 280,286 ****
  ** flag is set.  NULL is returned.
  **
  ** If another element already exists with the same key, then the
! ** new data replaces the old data and the old data is returned.
  ** The key is not copied in this instance.  If a malloc fails, then
  ** the new data is returned and the hash table is unchanged.
  **
--- 280,286 ----
  ** flag is set.  NULL is returned.
  **
  ** If another element already exists with the same key, then the
! ** new data replaces the old data and the old data is returned.
  ** The key is not copied in this instance.  If a malloc fails, then
  ** the new data is returned and the hash table is unchanged.
  **
diff -c ../sqlite-2.8.17/src/main.c src/main.c
*** ../sqlite-2.8.17/src/main.c	2005-04-23 18:43:22.000000000 -0400
--- src/main.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 64,69 ****
--- 64,70 ----
      return 1;
    }
    switch( argv[0][0] ){
+     case 'p':
      case 'v':
      case 'i':
      case 't': {  /* CREATE TABLE, CREATE INDEX, or CREATE VIEW statements */
***************
*** 348,353 ****
--- 349,355 ----
    rc = sqlite_exec(db, zSql, sqliteInitCallback, &initData, 0);
  
    sqliteFree(zSql);
+ 	sqliteDoDefDDL(db, 0);
    sqliteSafetyOn(db);
    sqliteBtreeCloseCursor(curMain);
    if( sqlite_malloc_failed ){
***************
*** 491,496 ****
--- 493,499 ----
      sqliteHashInit(&db->aDb[i].tblHash, SQLITE_HASH_STRING, 0);
      sqliteHashInit(&db->aDb[i].idxHash, SQLITE_HASH_STRING, 0);
      sqliteHashInit(&db->aDb[i].trigHash, SQLITE_HASH_STRING, 0);
+     sqliteHashInit(&db->aDb[i].objectHash, SQLITE_HASH_STRING, 0);
      sqliteHashInit(&db->aDb[i].aFKey, SQLITE_HASH_STRING, 1);
    }
    
***************
*** 517,523 ****
    sqliteRegisterBuiltinFunctions(db);
    rc = sqliteInit(db, pzErrMsg);
    db->magic = SQLITE_MAGIC_OPEN;
!   if( sqlite_malloc_failed ){
      sqlite_close(db);
      goto no_mem_on_open;
    }else if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){
--- 520,526 ----
    sqliteRegisterBuiltinFunctions(db);
    rc = sqliteInit(db, pzErrMsg);
    db->magic = SQLITE_MAGIC_OPEN;
!   if( sqlite_malloc_failed ){
      sqlite_close(db);
      goto no_mem_on_open;
    }else if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){
***************
*** 606,613 ****
        db->aDb[i].inTrans = 0;
      }
    }
!   sqliteResetInternalSchema(db, 0);
!   /* sqliteRollbackInternalChanges(db); */
  }
  
  /*
--- 609,617 ----
        db->aDb[i].inTrans = 0;
      }
    }
!   if( db->flags & SQLITE_InternChanges ){
!     sqliteResetInternalSchema(db, 0);
!   }
  }
  
  /*
Only in src/: opcodes.c
Only in src/: opcodes.h
diff -c ../sqlite-2.8.17/src/os.c src/os.c
*** ../sqlite-2.8.17/src/os.c	2005-06-06 09:09:17.000000000 -0400
--- src/os.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 113,119 ****
  #endif
  
  
! #if OS_UNIX
  /*
  ** Here is the dirt on POSIX advisory locks:  ANSI STD 1003.1 (1996)
  ** section 6.5.2.2 lines 483 through 490 specify that when a process
--- 113,119 ----
  #endif
  
  
! #if OS_UNIX
  /*
  ** Here is the dirt on POSIX advisory locks:  ANSI STD 1003.1 (1996)
  ** section 6.5.2.2 lines 483 through 490 specify that when a process
***************
*** 541,547 ****
        else
          *pReadonly = 1;
      } else
!       *pReadonly = 0;
    } else
      *pReadonly = 0;
  # else
--- 541,547 ----
        else
          *pReadonly = 1;
      } else
!       *pReadonly = 0;
    } else
      *pReadonly = 0;
  # else
***************
*** 650,656 ****
    if( FSpMakeFSRef(&fsSpec, &fsRef) != noErr )
      return SQLITE_CANTOPEN;
    FSGetDataForkName(&dfName);
!   if( FSOpenFork(&fsRef, dfName.length, dfName.unicode,
                   fsRdWrPerm, &(id->refNum)) != noErr )
      return SQLITE_CANTOPEN;
  # else
--- 650,656 ----
    if( FSpMakeFSRef(&fsSpec, &fsRef) != noErr )
      return SQLITE_CANTOPEN;
    FSGetDataForkName(&dfName);
!   if( FSOpenFork(&fsRef, dfName.length, dfName.unicode,
                   fsRdWrPerm, &(id->refNum)) != noErr )
      return SQLITE_CANTOPEN;
  # else
diff -c ../sqlite-2.8.17/src/pager.c src/pager.c
*** ../sqlite-2.8.17/src/pager.c	2005-12-19 12:37:10.000000000 -0500
--- src/pager.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 363,369 ****
      ac[1] = (val>>16) & 0xff;
      ac[2] = (val>>8) & 0xff;
      ac[3] = val & 0xff;
!   }
  }
  
  
--- 363,369 ----
      ac[1] = (val>>16) & 0xff;
      ac[2] = (val>>8) & 0xff;
      ac[3] = val & 0xff;
!   }
  }
  
  
Only in src/: parse.c
Only in src/: parse.h
diff -c ../sqlite-2.8.17/src/parse.y src/parse.y
*** ../sqlite-2.8.17/src/parse.y	2005-04-23 18:43:22.000000000 -0400
--- src/parse.y	2013-06-01 13:15:13.000000000 -0400
***************
*** 1,897 ****
! /*
! ** 2001 September 15
! **
! ** The author disclaims copyright to this source code.  In place of
! ** a legal notice, here is a blessing:
! **
! **    May you do good and not evil.
! **    May you find forgiveness for yourself and forgive others.
! **    May you share freely, never taking more than you give.
! **
! *************************************************************************
! ** This file contains SQLite's grammar for SQL.  Process this file
! ** using the lemon parser generator to generate C code that runs
! ** the parser.  Lemon will also generate a header file containing
! ** numeric codes for all of the tokens.
! **
! ** @(#) $Id: parse.y,v 1.112 2004/02/22 18:40:57 drh Exp $
! */
! %token_prefix TK_
! %token_type {Token}
! %default_type {Token}
! %extra_argument {Parse *pParse}
! %syntax_error {
!   if( pParse->zErrMsg==0 ){
!     if( TOKEN.z[0] ){
!       sqliteErrorMsg(pParse, "near \"%T\": syntax error", &TOKEN);
!     }else{
!       sqliteErrorMsg(pParse, "incomplete SQL statement");
!     }
!   }
! }
! %name sqliteParser
! %include {
! #include "sqliteInt.h"
! #include "parse.h"
! 
! /*
! ** An instance of this structure holds information about the
! ** LIMIT clause of a SELECT statement.
! */
! struct LimitVal {
!   int limit;    /* The LIMIT value.  -1 if there is no limit */
!   int offset;   /* The OFFSET.  0 if there is none */
! };
! 
! /*
! ** An instance of the following structure describes the event of a
! ** TRIGGER.  "a" is the event type, one of TK_UPDATE, TK_INSERT,
! ** TK_DELETE, or TK_INSTEAD.  If the event is of the form
! **
! **      UPDATE ON (a,b,c)
! **
! ** Then the "b" IdList records the list "a,b,c".
! */
! struct TrigEvent { int a; IdList * b; };
! 
! } // end %include
! 
! // These are extra tokens used by the lexer but never seen by the
! // parser.  We put them in a rule so that the parser generator will
! // add them to the parse.h output file.
! //
! %nonassoc END_OF_FILE ILLEGAL SPACE UNCLOSED_STRING COMMENT FUNCTION
!           COLUMN AGG_FUNCTION.
! 
! // Input is a single SQL command
! input ::= cmdlist.
! cmdlist ::= cmdlist ecmd.
! cmdlist ::= ecmd.
! ecmd ::= explain cmdx SEMI.
! ecmd ::= SEMI.
! cmdx ::= cmd.           { sqliteExec(pParse); }
! explain ::= EXPLAIN.    { sqliteBeginParse(pParse, 1); }
! explain ::= .           { sqliteBeginParse(pParse, 0); }
! 
! ///////////////////// Begin and end transactions. ////////////////////////////
! //
! 
! cmd ::= BEGIN trans_opt onconf(R).  {sqliteBeginTransaction(pParse,R);}
! trans_opt ::= .
! trans_opt ::= TRANSACTION.
! trans_opt ::= TRANSACTION nm.
! cmd ::= COMMIT trans_opt.      {sqliteCommitTransaction(pParse);}
! cmd ::= END trans_opt.         {sqliteCommitTransaction(pParse);}
! cmd ::= ROLLBACK trans_opt.    {sqliteRollbackTransaction(pParse);}
! 
! ///////////////////// The CREATE TABLE statement ////////////////////////////
! //
! cmd ::= create_table create_table_args.
! create_table ::= CREATE(X) temp(T) TABLE nm(Y). {
!    sqliteStartTable(pParse,&X,&Y,T,0);
! }
! %type temp {int}
! temp(A) ::= TEMP.  {A = 1;}
! temp(A) ::= .      {A = 0;}
! create_table_args ::= LP columnlist conslist_opt RP(X). {
!   sqliteEndTable(pParse,&X,0);
! }
! create_table_args ::= AS select(S). {
!   sqliteEndTable(pParse,0,S);
!   sqliteSelectDelete(S);
! }
! columnlist ::= columnlist COMMA column.
! columnlist ::= column.
! 
! // About the only information used for a column is the name of the
! // column.  The type is always just "text".  But the code will accept
! // an elaborate typename.  Perhaps someday we'll do something with it.
! //
! column ::= columnid type carglist. 
! columnid ::= nm(X).                {sqliteAddColumn(pParse,&X);}
! 
! // An IDENTIFIER can be a generic identifier, or one of several
! // keywords.  Any non-standard keyword can also be an identifier.
! //
! %type id {Token}
! id(A) ::= ID(X).         {A = X;}
! 
! // The following directive causes tokens ABORT, AFTER, ASC, etc. to
! // fallback to ID if they will not parse as their original value.
! // This obviates the need for the "id" nonterminal.
! //
! %fallback ID
!   ABORT AFTER ASC ATTACH BEFORE BEGIN CASCADE CLUSTER CONFLICT
!   COPY DATABASE DEFERRED DELIMITERS DESC DETACH EACH END EXPLAIN FAIL FOR
!   GLOB IGNORE IMMEDIATE INITIALLY INSTEAD LIKE MATCH KEY
!   OF OFFSET PRAGMA RAISE REPLACE RESTRICT ROW STATEMENT
!   TEMP TRIGGER VACUUM VIEW.
! 
! // Define operator precedence early so that this is the first occurance
! // of the operator tokens in the grammer.  Keeping the operators together
! // causes them to be assigned integer values that are close together,
! // which keeps parser tables smaller.
! //
! %left OR.
! %left AND.
! %right NOT.
! %left EQ NE ISNULL NOTNULL IS LIKE GLOB BETWEEN IN.
! %left GT GE LT LE.
! %left BITAND BITOR LSHIFT RSHIFT.
! %left PLUS MINUS.
! %left STAR SLASH REM.
! %left CONCAT.
! %right UMINUS UPLUS BITNOT.
! 
! // And "ids" is an identifer-or-string.
! //
! %type ids {Token}
! ids(A) ::= ID(X).        {A = X;}
! ids(A) ::= STRING(X).    {A = X;}
! 
! // The name of a column or table can be any of the following:
! //
! %type nm {Token}
! nm(A) ::= ID(X).         {A = X;}
! nm(A) ::= STRING(X).     {A = X;}
! nm(A) ::= JOIN_KW(X).    {A = X;}
! 
! type ::= .
! type ::= typename(X).                    {sqliteAddColumnType(pParse,&X,&X);}
! type ::= typename(X) LP signed RP(Y).    {sqliteAddColumnType(pParse,&X,&Y);}
! type ::= typename(X) LP signed COMMA signed RP(Y).
!                                          {sqliteAddColumnType(pParse,&X,&Y);}
! %type typename {Token}
! typename(A) ::= ids(X).           {A = X;}
! typename(A) ::= typename(X) ids.  {A = X;}
! %type signed {int}
! signed(A) ::= INTEGER(X).         { A = atoi(X.z); }
! signed(A) ::= PLUS INTEGER(X).    { A = atoi(X.z); }
! signed(A) ::= MINUS INTEGER(X).   { A = -atoi(X.z); }
! carglist ::= carglist carg.
! carglist ::= .
! carg ::= CONSTRAINT nm ccons.
! carg ::= ccons.
! carg ::= DEFAULT STRING(X).          {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT ID(X).              {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT INTEGER(X).         {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT PLUS INTEGER(X).    {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT MINUS INTEGER(X).   {sqliteAddDefaultValue(pParse,&X,1);}
! carg ::= DEFAULT FLOAT(X).           {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT PLUS FLOAT(X).      {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT MINUS FLOAT(X).     {sqliteAddDefaultValue(pParse,&X,1);}
! carg ::= DEFAULT NULL. 
! 
! // In addition to the type name, we also care about the primary key and
! // UNIQUE constraints.
! //
! ccons ::= NULL onconf.
! ccons ::= NOT NULL onconf(R).               {sqliteAddNotNull(pParse, R);}
! ccons ::= PRIMARY KEY sortorder onconf(R).  {sqliteAddPrimaryKey(pParse,0,R);}
! ccons ::= UNIQUE onconf(R).           {sqliteCreateIndex(pParse,0,0,0,R,0,0);}
! ccons ::= CHECK LP expr RP onconf.
! ccons ::= REFERENCES nm(T) idxlist_opt(TA) refargs(R).
!                                 {sqliteCreateForeignKey(pParse,0,&T,TA,R);}
! ccons ::= defer_subclause(D).   {sqliteDeferForeignKey(pParse,D);}
! ccons ::= COLLATE id(C).  {
!    sqliteAddCollateType(pParse, sqliteCollateType(C.z, C.n));
! }
! 
! // The next group of rules parses the arguments to a REFERENCES clause
! // that determine if the referential integrity checking is deferred or
! // or immediate and which determine what action to take if a ref-integ
! // check fails.
! //
! %type refargs {int}
! refargs(A) ::= .                     { A = OE_Restrict * 0x010101; }
! refargs(A) ::= refargs(X) refarg(Y). { A = (X & Y.mask) | Y.value; }
! %type refarg {struct {int value; int mask;}}
! refarg(A) ::= MATCH nm.              { A.value = 0;     A.mask = 0x000000; }
! refarg(A) ::= ON DELETE refact(X).   { A.value = X;     A.mask = 0x0000ff; }
! refarg(A) ::= ON UPDATE refact(X).   { A.value = X<<8;  A.mask = 0x00ff00; }
! refarg(A) ::= ON INSERT refact(X).   { A.value = X<<16; A.mask = 0xff0000; }
! %type refact {int}
! refact(A) ::= SET NULL.              { A = OE_SetNull; }
! refact(A) ::= SET DEFAULT.           { A = OE_SetDflt; }
! refact(A) ::= CASCADE.               { A = OE_Cascade; }
! refact(A) ::= RESTRICT.              { A = OE_Restrict; }
! %type defer_subclause {int}
! defer_subclause(A) ::= NOT DEFERRABLE init_deferred_pred_opt(X).  {A = X;}
! defer_subclause(A) ::= DEFERRABLE init_deferred_pred_opt(X).      {A = X;}
! %type init_deferred_pred_opt {int}
! init_deferred_pred_opt(A) ::= .                       {A = 0;}
! init_deferred_pred_opt(A) ::= INITIALLY DEFERRED.     {A = 1;}
! init_deferred_pred_opt(A) ::= INITIALLY IMMEDIATE.    {A = 0;}
! 
! // For the time being, the only constraint we care about is the primary
! // key and UNIQUE.  Both create indices.
! //
! conslist_opt ::= .
! conslist_opt ::= COMMA conslist.
! conslist ::= conslist COMMA tcons.
! conslist ::= conslist tcons.
! conslist ::= tcons.
! tcons ::= CONSTRAINT nm.
! tcons ::= PRIMARY KEY LP idxlist(X) RP onconf(R).
!                                              {sqliteAddPrimaryKey(pParse,X,R);}
! tcons ::= UNIQUE LP idxlist(X) RP onconf(R).
!                                        {sqliteCreateIndex(pParse,0,0,X,R,0,0);}
! tcons ::= CHECK expr onconf.
! tcons ::= FOREIGN KEY LP idxlist(FA) RP
!           REFERENCES nm(T) idxlist_opt(TA) refargs(R) defer_subclause_opt(D). {
!     sqliteCreateForeignKey(pParse, FA, &T, TA, R);
!     sqliteDeferForeignKey(pParse, D);
! }
! %type defer_subclause_opt {int}
! defer_subclause_opt(A) ::= .                    {A = 0;}
! defer_subclause_opt(A) ::= defer_subclause(X).  {A = X;}
! 
! // The following is a non-standard extension that allows us to declare the
! // default behavior when there is a constraint conflict.
! //
! %type onconf {int}
! %type orconf {int}
! %type resolvetype {int}
! onconf(A) ::= .                              { A = OE_Default; }
! onconf(A) ::= ON CONFLICT resolvetype(X).    { A = X; }
! orconf(A) ::= .                              { A = OE_Default; }
! orconf(A) ::= OR resolvetype(X).             { A = X; }
! resolvetype(A) ::= ROLLBACK.                 { A = OE_Rollback; }
! resolvetype(A) ::= ABORT.                    { A = OE_Abort; }
! resolvetype(A) ::= FAIL.                     { A = OE_Fail; }
! resolvetype(A) ::= IGNORE.                   { A = OE_Ignore; }
! resolvetype(A) ::= REPLACE.                  { A = OE_Replace; }
! 
! ////////////////////////// The DROP TABLE /////////////////////////////////////
! //
! cmd ::= DROP TABLE nm(X).          {sqliteDropTable(pParse,&X,0);}
! 
! ///////////////////// The CREATE VIEW statement /////////////////////////////
! //
! cmd ::= CREATE(X) temp(T) VIEW nm(Y) AS select(S). {
!   sqliteCreateView(pParse, &X, &Y, S, T);
! }
! cmd ::= DROP VIEW nm(X). {
!   sqliteDropTable(pParse, &X, 1);
! }
! 
! //////////////////////// The SELECT statement /////////////////////////////////
! //
! cmd ::= select(X).  {
!   sqliteSelect(pParse, X, SRT_Callback, 0, 0, 0, 0);
!   sqliteSelectDelete(X);
! }
! 
! %type select {Select*}
! %destructor select {sqliteSelectDelete($$);}
! %type oneselect {Select*}
! %destructor oneselect {sqliteSelectDelete($$);}
! 
! select(A) ::= oneselect(X).                      {A = X;}
! select(A) ::= select(X) multiselect_op(Y) oneselect(Z).  {
!   if( Z ){
!     Z->op = Y;
!     Z->pPrior = X;
!   }
!   A = Z;
! }
! %type multiselect_op {int}
! multiselect_op(A) ::= UNION.      {A = TK_UNION;}
! multiselect_op(A) ::= UNION ALL.  {A = TK_ALL;}
! multiselect_op(A) ::= INTERSECT.  {A = TK_INTERSECT;}
! multiselect_op(A) ::= EXCEPT.     {A = TK_EXCEPT;}
! oneselect(A) ::= SELECT distinct(D) selcollist(W) from(X) where_opt(Y)
!                  groupby_opt(P) having_opt(Q) orderby_opt(Z) limit_opt(L). {
!   A = sqliteSelectNew(W,X,Y,P,Q,Z,D,L.limit,L.offset);
! }
! 
! // The "distinct" nonterminal is true (1) if the DISTINCT keyword is
! // present and false (0) if it is not.
! //
! %type distinct {int}
! distinct(A) ::= DISTINCT.   {A = 1;}
! distinct(A) ::= ALL.        {A = 0;}
! distinct(A) ::= .           {A = 0;}
! 
! // selcollist is a list of expressions that are to become the return
! // values of the SELECT statement.  The "*" in statements like
! // "SELECT * FROM ..." is encoded as a special expression with an
! // opcode of TK_ALL.
! //
! %type selcollist {ExprList*}
! %destructor selcollist {sqliteExprListDelete($$);}
! %type sclp {ExprList*}
! %destructor sclp {sqliteExprListDelete($$);}
! sclp(A) ::= selcollist(X) COMMA.             {A = X;}
! sclp(A) ::= .                                {A = 0;}
! selcollist(A) ::= sclp(P) expr(X) as(Y).     {
!    A = sqliteExprListAppend(P,X,Y.n?&Y:0);
! }
! selcollist(A) ::= sclp(P) STAR. {
!   A = sqliteExprListAppend(P, sqliteExpr(TK_ALL, 0, 0, 0), 0);
! }
! selcollist(A) ::= sclp(P) nm(X) DOT STAR. {
!   Expr *pRight = sqliteExpr(TK_ALL, 0, 0, 0);
!   Expr *pLeft = sqliteExpr(TK_ID, 0, 0, &X);
!   A = sqliteExprListAppend(P, sqliteExpr(TK_DOT, pLeft, pRight, 0), 0);
! }
! 
! // An option "AS <id>" phrase that can follow one of the expressions that
! // define the result set, or one of the tables in the FROM clause.
! //
! %type as {Token}
! as(X) ::= AS nm(Y).    { X = Y; }
! as(X) ::= ids(Y).      { X = Y; }
! as(X) ::= .            { X.n = 0; }
! 
! 
! %type seltablist {SrcList*}
! %destructor seltablist {sqliteSrcListDelete($$);}
! %type stl_prefix {SrcList*}
! %destructor stl_prefix {sqliteSrcListDelete($$);}
! %type from {SrcList*}
! %destructor from {sqliteSrcListDelete($$);}
! 
! // A complete FROM clause.
! //
! from(A) ::= .                                 {A = sqliteMalloc(sizeof(*A));}
! from(A) ::= FROM seltablist(X).               {A = X;}
! 
! // "seltablist" is a "Select Table List" - the content of the FROM clause
! // in a SELECT statement.  "stl_prefix" is a prefix of this list.
! //
! stl_prefix(A) ::= seltablist(X) joinop(Y).    {
!    A = X;
!    if( A && A->nSrc>0 ) A->a[A->nSrc-1].jointype = Y;
! }
! stl_prefix(A) ::= .                           {A = 0;}
! seltablist(A) ::= stl_prefix(X) nm(Y) dbnm(D) as(Z) on_opt(N) using_opt(U). {
!   A = sqliteSrcListAppend(X,&Y,&D);
!   if( Z.n ) sqliteSrcListAddAlias(A,&Z);
!   if( N ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pOn = N; }
!     else { sqliteExprDelete(N); }
!   }
!   if( U ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pUsing = U; }
!     else { sqliteIdListDelete(U); }
!   }
! }
! seltablist(A) ::= stl_prefix(X) LP seltablist_paren(S) RP
!                   as(Z) on_opt(N) using_opt(U). {
!   A = sqliteSrcListAppend(X,0,0);
!   A->a[A->nSrc-1].pSelect = S;
!   if( Z.n ) sqliteSrcListAddAlias(A,&Z);
!   if( N ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pOn = N; }
!     else { sqliteExprDelete(N); }
!   }
!   if( U ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pUsing = U; }
!     else { sqliteIdListDelete(U); }
!   }
! }
! 
! // A seltablist_paren nonterminal represents anything in a FROM that
! // is contained inside parentheses.  This can be either a subquery or
! // a grouping of table and subqueries.
! //
! %type seltablist_paren {Select*}
! %destructor seltablist_paren {sqliteSelectDelete($$);}
! seltablist_paren(A) ::= select(S).      {A = S;}
! seltablist_paren(A) ::= seltablist(F).  {
!    A = sqliteSelectNew(0,F,0,0,0,0,0,-1,0);
! }
! 
! %type dbnm {Token}
! dbnm(A) ::= .          {A.z=0; A.n=0;}
! dbnm(A) ::= DOT nm(X). {A = X;}
! 
! %type joinop {int}
! %type joinop2 {int}
! joinop(X) ::= COMMA.                   { X = JT_INNER; }
! joinop(X) ::= JOIN.                    { X = JT_INNER; }
! joinop(X) ::= JOIN_KW(A) JOIN.         { X = sqliteJoinType(pParse,&A,0,0); }
! joinop(X) ::= JOIN_KW(A) nm(B) JOIN.   { X = sqliteJoinType(pParse,&A,&B,0); }
! joinop(X) ::= JOIN_KW(A) nm(B) nm(C) JOIN.
!                                        { X = sqliteJoinType(pParse,&A,&B,&C); }
! 
! %type on_opt {Expr*}
! %destructor on_opt {sqliteExprDelete($$);}
! on_opt(N) ::= ON expr(E).   {N = E;}
! on_opt(N) ::= .             {N = 0;}
! 
! %type using_opt {IdList*}
! %destructor using_opt {sqliteIdListDelete($$);}
! using_opt(U) ::= USING LP idxlist(L) RP.  {U = L;}
! using_opt(U) ::= .                        {U = 0;}
! 
! 
! %type orderby_opt {ExprList*}
! %destructor orderby_opt {sqliteExprListDelete($$);}
! %type sortlist {ExprList*}
! %destructor sortlist {sqliteExprListDelete($$);}
! %type sortitem {Expr*}
! %destructor sortitem {sqliteExprDelete($$);}
! 
! orderby_opt(A) ::= .                          {A = 0;}
! orderby_opt(A) ::= ORDER BY sortlist(X).      {A = X;}
! sortlist(A) ::= sortlist(X) COMMA sortitem(Y) collate(C) sortorder(Z). {
!   A = sqliteExprListAppend(X,Y,0);
!   if( A ) A->a[A->nExpr-1].sortOrder = C+Z;
! }
! sortlist(A) ::= sortitem(Y) collate(C) sortorder(Z). {
!   A = sqliteExprListAppend(0,Y,0);
!   if( A ) A->a[0].sortOrder = C+Z;
! }
! sortitem(A) ::= expr(X).   {A = X;}
! 
! %type sortorder {int}
! %type collate {int}
! 
! sortorder(A) ::= ASC.           {A = SQLITE_SO_ASC;}
! sortorder(A) ::= DESC.          {A = SQLITE_SO_DESC;}
! sortorder(A) ::= .              {A = SQLITE_SO_ASC;}
! collate(C) ::= .                {C = SQLITE_SO_UNK;}
! collate(C) ::= COLLATE id(X).   {C = sqliteCollateType(X.z, X.n);}
! 
! %type groupby_opt {ExprList*}
! %destructor groupby_opt {sqliteExprListDelete($$);}
! groupby_opt(A) ::= .                      {A = 0;}
! groupby_opt(A) ::= GROUP BY exprlist(X).  {A = X;}
! 
! %type having_opt {Expr*}
! %destructor having_opt {sqliteExprDelete($$);}
! having_opt(A) ::= .                {A = 0;}
! having_opt(A) ::= HAVING expr(X).  {A = X;}
! 
! %type limit_opt {struct LimitVal}
! limit_opt(A) ::= .                     {A.limit = -1; A.offset = 0;}
! limit_opt(A) ::= LIMIT signed(X).      {A.limit = X; A.offset = 0;}
! limit_opt(A) ::= LIMIT signed(X) OFFSET signed(Y). 
!                                        {A.limit = X; A.offset = Y;}
! limit_opt(A) ::= LIMIT signed(X) COMMA signed(Y). 
!                                        {A.limit = Y; A.offset = X;}
! 
! /////////////////////////// The DELETE statement /////////////////////////////
! //
! cmd ::= DELETE FROM nm(X) dbnm(D) where_opt(Y). {
!    sqliteDeleteFrom(pParse, sqliteSrcListAppend(0,&X,&D), Y);
! }
! 
! %type where_opt {Expr*}
! %destructor where_opt {sqliteExprDelete($$);}
! 
! where_opt(A) ::= .                    {A = 0;}
! where_opt(A) ::= WHERE expr(X).       {A = X;}
! 
! %type setlist {ExprList*}
! %destructor setlist {sqliteExprListDelete($$);}
! 
! ////////////////////////// The UPDATE command ////////////////////////////////
! //
! cmd ::= UPDATE orconf(R) nm(X) dbnm(D) SET setlist(Y) where_opt(Z).
!     {sqliteUpdate(pParse,sqliteSrcListAppend(0,&X,&D),Y,Z,R);}
! 
! setlist(A) ::= setlist(Z) COMMA nm(X) EQ expr(Y).
!     {A = sqliteExprListAppend(Z,Y,&X);}
! setlist(A) ::= nm(X) EQ expr(Y).   {A = sqliteExprListAppend(0,Y,&X);}
! 
! ////////////////////////// The INSERT command /////////////////////////////////
! //
! cmd ::= insert_cmd(R) INTO nm(X) dbnm(D) inscollist_opt(F) 
!         VALUES LP itemlist(Y) RP.
!             {sqliteInsert(pParse, sqliteSrcListAppend(0,&X,&D), Y, 0, F, R);}
! cmd ::= insert_cmd(R) INTO nm(X) dbnm(D) inscollist_opt(F) select(S).
!             {sqliteInsert(pParse, sqliteSrcListAppend(0,&X,&D), 0, S, F, R);}
! 
! %type insert_cmd {int}
! insert_cmd(A) ::= INSERT orconf(R).   {A = R;}
! insert_cmd(A) ::= REPLACE.            {A = OE_Replace;}
! 
! 
! %type itemlist {ExprList*}
! %destructor itemlist {sqliteExprListDelete($$);}
! 
! itemlist(A) ::= itemlist(X) COMMA expr(Y).  {A = sqliteExprListAppend(X,Y,0);}
! itemlist(A) ::= expr(X).                    {A = sqliteExprListAppend(0,X,0);}
! 
! %type inscollist_opt {IdList*}
! %destructor inscollist_opt {sqliteIdListDelete($$);}
! %type inscollist {IdList*}
! %destructor inscollist {sqliteIdListDelete($$);}
! 
! inscollist_opt(A) ::= .                       {A = 0;}
! inscollist_opt(A) ::= LP inscollist(X) RP.    {A = X;}
! inscollist(A) ::= inscollist(X) COMMA nm(Y).  {A = sqliteIdListAppend(X,&Y);}
! inscollist(A) ::= nm(Y).                      {A = sqliteIdListAppend(0,&Y);}
! 
! /////////////////////////// Expression Processing /////////////////////////////
! //
! 
! %type expr {Expr*}
! %destructor expr {sqliteExprDelete($$);}
! 
! expr(A) ::= LP(B) expr(X) RP(E). {A = X; sqliteExprSpan(A,&B,&E); }
! expr(A) ::= NULL(X).             {A = sqliteExpr(TK_NULL, 0, 0, &X);}
! expr(A) ::= ID(X).               {A = sqliteExpr(TK_ID, 0, 0, &X);}
! expr(A) ::= JOIN_KW(X).          {A = sqliteExpr(TK_ID, 0, 0, &X);}
! expr(A) ::= nm(X) DOT nm(Y). {
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   Expr *temp2 = sqliteExpr(TK_ID, 0, 0, &Y);
!   A = sqliteExpr(TK_DOT, temp1, temp2, 0);
! }
! expr(A) ::= nm(X) DOT nm(Y) DOT nm(Z). {
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   Expr *temp2 = sqliteExpr(TK_ID, 0, 0, &Y);
!   Expr *temp3 = sqliteExpr(TK_ID, 0, 0, &Z);
!   Expr *temp4 = sqliteExpr(TK_DOT, temp2, temp3, 0);
!   A = sqliteExpr(TK_DOT, temp1, temp4, 0);
! }
! expr(A) ::= INTEGER(X).      {A = sqliteExpr(TK_INTEGER, 0, 0, &X);}
! expr(A) ::= FLOAT(X).        {A = sqliteExpr(TK_FLOAT, 0, 0, &X);}
! expr(A) ::= STRING(X).       {A = sqliteExpr(TK_STRING, 0, 0, &X);}
! expr(A) ::= VARIABLE(X).     {
!   A = sqliteExpr(TK_VARIABLE, 0, 0, &X);
!   if( A ) A->iTable = ++pParse->nVar;
! }
! expr(A) ::= ID(X) LP exprlist(Y) RP(E). {
!   A = sqliteExprFunction(Y, &X);
!   sqliteExprSpan(A,&X,&E);
! }
! expr(A) ::= ID(X) LP STAR RP(E). {
!   A = sqliteExprFunction(0, &X);
!   sqliteExprSpan(A,&X,&E);
! }
! expr(A) ::= expr(X) AND expr(Y).   {A = sqliteExpr(TK_AND, X, Y, 0);}
! expr(A) ::= expr(X) OR expr(Y).    {A = sqliteExpr(TK_OR, X, Y, 0);}
! expr(A) ::= expr(X) LT expr(Y).    {A = sqliteExpr(TK_LT, X, Y, 0);}
! expr(A) ::= expr(X) GT expr(Y).    {A = sqliteExpr(TK_GT, X, Y, 0);}
! expr(A) ::= expr(X) LE expr(Y).    {A = sqliteExpr(TK_LE, X, Y, 0);}
! expr(A) ::= expr(X) GE expr(Y).    {A = sqliteExpr(TK_GE, X, Y, 0);}
! expr(A) ::= expr(X) NE expr(Y).    {A = sqliteExpr(TK_NE, X, Y, 0);}
! expr(A) ::= expr(X) EQ expr(Y).    {A = sqliteExpr(TK_EQ, X, Y, 0);}
! expr(A) ::= expr(X) BITAND expr(Y). {A = sqliteExpr(TK_BITAND, X, Y, 0);}
! expr(A) ::= expr(X) BITOR expr(Y).  {A = sqliteExpr(TK_BITOR, X, Y, 0);}
! expr(A) ::= expr(X) LSHIFT expr(Y). {A = sqliteExpr(TK_LSHIFT, X, Y, 0);}
! expr(A) ::= expr(X) RSHIFT expr(Y). {A = sqliteExpr(TK_RSHIFT, X, Y, 0);}
! expr(A) ::= expr(X) likeop(OP) expr(Y).  [LIKE]  {
!   ExprList *pList = sqliteExprListAppend(0, Y, 0);
!   pList = sqliteExprListAppend(pList, X, 0);
!   A = sqliteExprFunction(pList, 0);
!   if( A ) A->op = OP;
!   sqliteExprSpan(A, &X->span, &Y->span);
! }
! expr(A) ::= expr(X) NOT likeop(OP) expr(Y). [LIKE] {
!   ExprList *pList = sqliteExprListAppend(0, Y, 0);
!   pList = sqliteExprListAppend(pList, X, 0);
!   A = sqliteExprFunction(pList, 0);
!   if( A ) A->op = OP;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,&Y->span);
! }
! %type likeop {int}
! likeop(A) ::= LIKE. {A = TK_LIKE;}
! likeop(A) ::= GLOB. {A = TK_GLOB;}
! expr(A) ::= expr(X) PLUS expr(Y).  {A = sqliteExpr(TK_PLUS, X, Y, 0);}
! expr(A) ::= expr(X) MINUS expr(Y). {A = sqliteExpr(TK_MINUS, X, Y, 0);}
! expr(A) ::= expr(X) STAR expr(Y).  {A = sqliteExpr(TK_STAR, X, Y, 0);}
! expr(A) ::= expr(X) SLASH expr(Y). {A = sqliteExpr(TK_SLASH, X, Y, 0);}
! expr(A) ::= expr(X) REM expr(Y).   {A = sqliteExpr(TK_REM, X, Y, 0);}
! expr(A) ::= expr(X) CONCAT expr(Y). {A = sqliteExpr(TK_CONCAT, X, Y, 0);}
! expr(A) ::= expr(X) ISNULL(E). {
!   A = sqliteExpr(TK_ISNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IS NULL(E). {
!   A = sqliteExpr(TK_ISNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOTNULL(E). {
!   A = sqliteExpr(TK_NOTNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOT NULL(E). {
!   A = sqliteExpr(TK_NOTNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IS NOT NULL(E). {
!   A = sqliteExpr(TK_NOTNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= NOT(B) expr(X). {
!   A = sqliteExpr(TK_NOT, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= BITNOT(B) expr(X). {
!   A = sqliteExpr(TK_BITNOT, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= MINUS(B) expr(X). [UMINUS] {
!   A = sqliteExpr(TK_UMINUS, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= PLUS(B) expr(X). [UPLUS] {
!   A = sqliteExpr(TK_UPLUS, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= LP(B) select(X) RP(E). {
!   A = sqliteExpr(TK_SELECT, 0, 0, 0);
!   if( A ) A->pSelect = X;
!   sqliteExprSpan(A,&B,&E);
! }
! expr(A) ::= expr(W) BETWEEN expr(X) AND expr(Y). {
!   ExprList *pList = sqliteExprListAppend(0, X, 0);
!   pList = sqliteExprListAppend(pList, Y, 0);
!   A = sqliteExpr(TK_BETWEEN, W, 0, 0);
!   if( A ) A->pList = pList;
!   sqliteExprSpan(A,&W->span,&Y->span);
! }
! expr(A) ::= expr(W) NOT BETWEEN expr(X) AND expr(Y). {
!   ExprList *pList = sqliteExprListAppend(0, X, 0);
!   pList = sqliteExprListAppend(pList, Y, 0);
!   A = sqliteExpr(TK_BETWEEN, W, 0, 0);
!   if( A ) A->pList = pList;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&W->span,&Y->span);
! }
! expr(A) ::= expr(X) IN LP exprlist(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pList = Y;
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IN LP select(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = Y;
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOT IN LP exprlist(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pList = Y;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOT IN LP select(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = Y;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IN nm(Y) dbnm(D). {
!   SrcList *pSrc = sqliteSrcListAppend(0, &Y, &D);
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = sqliteSelectNew(0,pSrc,0,0,0,0,0,-1,0);
!   sqliteExprSpan(A,&X->span,D.z?&D:&Y);
! }
! expr(A) ::= expr(X) NOT IN nm(Y) dbnm(D). {
!   SrcList *pSrc = sqliteSrcListAppend(0, &Y, &D);
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = sqliteSelectNew(0,pSrc,0,0,0,0,0,-1,0);
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,D.z?&D:&Y);
! }
! 
! 
! /* CASE expressions */
! expr(A) ::= CASE(C) case_operand(X) case_exprlist(Y) case_else(Z) END(E). {
!   A = sqliteExpr(TK_CASE, X, Z, 0);
!   if( A ) A->pList = Y;
!   sqliteExprSpan(A, &C, &E);
! }
! %type case_exprlist {ExprList*}
! %destructor case_exprlist {sqliteExprListDelete($$);}
! case_exprlist(A) ::= case_exprlist(X) WHEN expr(Y) THEN expr(Z). {
!   A = sqliteExprListAppend(X, Y, 0);
!   A = sqliteExprListAppend(A, Z, 0);
! }
! case_exprlist(A) ::= WHEN expr(Y) THEN expr(Z). {
!   A = sqliteExprListAppend(0, Y, 0);
!   A = sqliteExprListAppend(A, Z, 0);
! }
! %type case_else {Expr*}
! case_else(A) ::=  ELSE expr(X).         {A = X;}
! case_else(A) ::=  .                     {A = 0;} 
! %type case_operand {Expr*}
! case_operand(A) ::= expr(X).            {A = X;} 
! case_operand(A) ::= .                   {A = 0;} 
! 
! %type exprlist {ExprList*}
! %destructor exprlist {sqliteExprListDelete($$);}
! %type expritem {Expr*}
! %destructor expritem {sqliteExprDelete($$);}
! 
! exprlist(A) ::= exprlist(X) COMMA expritem(Y). 
!    {A = sqliteExprListAppend(X,Y,0);}
! exprlist(A) ::= expritem(X).            {A = sqliteExprListAppend(0,X,0);}
! expritem(A) ::= expr(X).                {A = X;}
! expritem(A) ::= .                       {A = 0;}
! 
! ///////////////////////////// The CREATE INDEX command ///////////////////////
! //
! cmd ::= CREATE(S) uniqueflag(U) INDEX nm(X)
!         ON nm(Y) dbnm(D) LP idxlist(Z) RP(E) onconf(R). {
!   SrcList *pSrc = sqliteSrcListAppend(0, &Y, &D);
!   if( U!=OE_None ) U = R;
!   if( U==OE_Default) U = OE_Abort;
!   sqliteCreateIndex(pParse, &X, pSrc, Z, U, &S, &E);
! }
! 
! %type uniqueflag {int}
! uniqueflag(A) ::= UNIQUE.  { A = OE_Abort; }
! uniqueflag(A) ::= .        { A = OE_None; }
! 
! %type idxlist {IdList*}
! %destructor idxlist {sqliteIdListDelete($$);}
! %type idxlist_opt {IdList*}
! %destructor idxlist_opt {sqliteIdListDelete($$);}
! %type idxitem {Token}
! 
! idxlist_opt(A) ::= .                         {A = 0;}
! idxlist_opt(A) ::= LP idxlist(X) RP.         {A = X;}
! idxlist(A) ::= idxlist(X) COMMA idxitem(Y).  {A = sqliteIdListAppend(X,&Y);}
! idxlist(A) ::= idxitem(Y).                   {A = sqliteIdListAppend(0,&Y);}
! idxitem(A) ::= nm(X) sortorder.              {A = X;}
! 
! ///////////////////////////// The DROP INDEX command /////////////////////////
! //
! 
! cmd ::= DROP INDEX nm(X) dbnm(Y).   {
!   sqliteDropIndex(pParse, sqliteSrcListAppend(0,&X,&Y));
! }
! 
! 
! ///////////////////////////// The COPY command ///////////////////////////////
! //
! cmd ::= COPY orconf(R) nm(X) dbnm(D) FROM nm(Y) USING DELIMITERS STRING(Z).
!     {sqliteCopy(pParse,sqliteSrcListAppend(0,&X,&D),&Y,&Z,R);}
! cmd ::= COPY orconf(R) nm(X) dbnm(D) FROM nm(Y).
!     {sqliteCopy(pParse,sqliteSrcListAppend(0,&X,&D),&Y,0,R);}
! 
! ///////////////////////////// The VACUUM command /////////////////////////////
! //
! cmd ::= VACUUM.                {sqliteVacuum(pParse,0);}
! cmd ::= VACUUM nm(X).         {sqliteVacuum(pParse,&X);}
! 
! ///////////////////////////// The PRAGMA command /////////////////////////////
! //
! cmd ::= PRAGMA ids(X) EQ nm(Y).         {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X) EQ ON(Y).          {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X) EQ plus_num(Y).    {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X) EQ minus_num(Y).   {sqlitePragma(pParse,&X,&Y,1);}
! cmd ::= PRAGMA ids(X) LP nm(Y) RP.      {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X).                   {sqlitePragma(pParse,&X,&X,0);}
! plus_num(A) ::= plus_opt number(X).   {A = X;}
! minus_num(A) ::= MINUS number(X).     {A = X;}
! number(A) ::= INTEGER(X).  {A = X;}
! number(A) ::= FLOAT(X).    {A = X;}
! plus_opt ::= PLUS.
! plus_opt ::= .
! 
! //////////////////////////// The CREATE TRIGGER command /////////////////////
! 
! cmd ::= CREATE(A) trigger_decl BEGIN trigger_cmd_list(S) END(Z). {
!   Token all;
!   all.z = A.z;
!   all.n = (Z.z - A.z) + Z.n;
!   sqliteFinishTrigger(pParse, S, &all);
! }
! 
! trigger_decl ::= temp(T) TRIGGER nm(B) trigger_time(C) trigger_event(D)
!                  ON nm(E) dbnm(DB) foreach_clause(F) when_clause(G). {
!   SrcList *pTab = sqliteSrcListAppend(0, &E, &DB);
!   sqliteBeginTrigger(pParse, &B, C, D.a, D.b, pTab, F, G, T);
! }
! 
! %type trigger_time  {int}
! trigger_time(A) ::= BEFORE.      { A = TK_BEFORE; }
! trigger_time(A) ::= AFTER.       { A = TK_AFTER;  }
! trigger_time(A) ::= INSTEAD OF.  { A = TK_INSTEAD;}
! trigger_time(A) ::= .            { A = TK_BEFORE; }
! 
! %type trigger_event {struct TrigEvent}
! %destructor trigger_event {sqliteIdListDelete($$.b);}
! trigger_event(A) ::= DELETE. { A.a = TK_DELETE; A.b = 0; }
! trigger_event(A) ::= INSERT. { A.a = TK_INSERT; A.b = 0; }
! trigger_event(A) ::= UPDATE. { A.a = TK_UPDATE; A.b = 0;}
! trigger_event(A) ::= UPDATE OF inscollist(X). {A.a = TK_UPDATE; A.b = X; }
! 
! %type foreach_clause {int}
! foreach_clause(A) ::= .                   { A = TK_ROW; }
! foreach_clause(A) ::= FOR EACH ROW.       { A = TK_ROW; }
! foreach_clause(A) ::= FOR EACH STATEMENT. { A = TK_STATEMENT; }
! 
! %type when_clause {Expr *}
! when_clause(A) ::= .             { A = 0; }
! when_clause(A) ::= WHEN expr(X). { A = X; }
! 
! %type trigger_cmd_list {TriggerStep *}
! %destructor trigger_cmd_list {sqliteDeleteTriggerStep($$);}
! trigger_cmd_list(A) ::= trigger_cmd(X) SEMI trigger_cmd_list(Y). {
!   X->pNext = Y;
!   A = X;
! }
! trigger_cmd_list(A) ::= . { A = 0; }
! 
! %type trigger_cmd {TriggerStep *}
! %destructor trigger_cmd {sqliteDeleteTriggerStep($$);}
! // UPDATE 
! trigger_cmd(A) ::= UPDATE orconf(R) nm(X) SET setlist(Y) where_opt(Z).  
!                { A = sqliteTriggerUpdateStep(&X, Y, Z, R); }
! 
! // INSERT
! trigger_cmd(A) ::= insert_cmd(R) INTO nm(X) inscollist_opt(F) 
!   VALUES LP itemlist(Y) RP.  
! {A = sqliteTriggerInsertStep(&X, F, Y, 0, R);}
! 
! trigger_cmd(A) ::= insert_cmd(R) INTO nm(X) inscollist_opt(F) select(S).
!                {A = sqliteTriggerInsertStep(&X, F, 0, S, R);}
! 
! // DELETE
! trigger_cmd(A) ::= DELETE FROM nm(X) where_opt(Y).
!                {A = sqliteTriggerDeleteStep(&X, Y);}
! 
! // SELECT
! trigger_cmd(A) ::= select(X).  {A = sqliteTriggerSelectStep(X); }
! 
! // The special RAISE expression that may occur in trigger programs
! expr(A) ::= RAISE(X) LP IGNORE RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, 0); 
!   A->iColumn = OE_Ignore;
!   sqliteExprSpan(A, &X, &Y);
! }
! expr(A) ::= RAISE(X) LP ROLLBACK COMMA nm(Z) RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, &Z); 
!   A->iColumn = OE_Rollback;
!   sqliteExprSpan(A, &X, &Y);
! }
! expr(A) ::= RAISE(X) LP ABORT COMMA nm(Z) RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, &Z); 
!   A->iColumn = OE_Abort;
!   sqliteExprSpan(A, &X, &Y);
! }
! expr(A) ::= RAISE(X) LP FAIL COMMA nm(Z) RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, &Z); 
!   A->iColumn = OE_Fail;
!   sqliteExprSpan(A, &X, &Y);
! }
! 
! ////////////////////////  DROP TRIGGER statement //////////////////////////////
! cmd ::= DROP TRIGGER nm(X) dbnm(D). {
!   sqliteDropTrigger(pParse,sqliteSrcListAppend(0,&X,&D));
! }
! 
! //////////////////////// ATTACH DATABASE file AS name /////////////////////////
! cmd ::= ATTACH database_kw_opt ids(F) AS nm(D) key_opt(K). {
!   sqliteAttach(pParse, &F, &D, &K);
! }
! %type key_opt {Token}
! key_opt(A) ::= USING ids(X).  { A = X; }
! key_opt(A) ::= .              { A.z = 0; A.n = 0; }
! 
! database_kw_opt ::= DATABASE.
! database_kw_opt ::= .
! 
! //////////////////////// DETACH DATABASE name /////////////////////////////////
! cmd ::= DETACH database_kw_opt nm(D). {
!   sqliteDetach(pParse, &D);
! }
--- 1,1112 ----
! /*
! ** 2001 September 15
! **
! ** The author disclaims copyright to this source code.  In place of
! ** a legal notice, here is a blessing:
! **
! **    May you do good and not evil.
! **    May you find forgiveness for yourself and forgive others.
! **    May you share freely, never taking more than you give.
! **
! *************************************************************************
! ** This file contains SQLite's grammar for SQL.  Process this file
! ** using the lemon parser generator to generate C code that runs
! ** the parser.  Lemon will also generate a header file containing
! ** numeric codes for all of the tokens.
! **
! ** @(#) $Id: parse.y,v 1.112 2004/02/22 18:40:57 drh Exp $
! */
! %token_prefix TK_
! %token_type {Token}
! %default_type {Token}
! %extra_argument {Parse *pParse}
! %syntax_error {
!   if( pParse->zErrMsg==0 ){
!     if( TOKEN.z[0] ){
!       sqliteErrorMsg(pParse, "near \"%T\": syntax error", &TOKEN);
!     }else{
!       sqliteErrorMsg(pParse, "incomplete SQL statement");
!     }
!   }
! }
! %name sqliteParser
! %include {
! #include "sqliteInt.h"
! #include "parse.h"
! 
! /*
! ** An instance of this structure holds information about the
! ** LIMIT clause of a SELECT statement.
! */
! struct LimitVal {
!   int limit;    /* The LIMIT value.  -1 if there is no limit */
!   int offset;   /* The OFFSET.  0 if there is none */
! };
! 
! /*
! ** An instance of the following structure describes the event of a
! ** TRIGGER.  "a" is the event type, one of TK_UPDATE, TK_INSERT,
! ** TK_DELETE, or TK_INSTEAD.  If the event is of the form
! **
! **      UPDATE ON (a,b,c)
! **
! ** Then the "b" IdList records the list "a,b,c".
! */
! struct TrigEvent { int a; IdList * b; };
! 
! } // end %include
! 
! // These are extra tokens used by the lexer but never seen by the
! // parser.  We put them in a rule so that the parser generator will
! // add them to the parse.h output file.
! //
! %nonassoc END_OF_FILE ILLEGAL SPACE UNCLOSED_STRING COMMENT FUNCTION
!           COLUMN AGG_FUNCTION BLOCK VAR ASSIGN SQL.
! 
! // Input is a single SQL command
! input ::= cmdlist.
! cmdlist ::= cmdlist ecmd.
! cmdlist ::= ecmd.
! ecmd ::= explain cmdx SEMI.
! ecmd ::= SEMI.
! cmdx ::= cmd.           { sqliteExec(pParse); }
! explain ::= EXPLAIN.    { sqliteBeginParse(pParse, 1); }
! explain ::= .           { sqliteBeginParse(pParse, 0); }
! 
! ///////////////////// Begin and end transactions. ////////////////////////////
! //
! 
! cmd ::= BEGIN trans_opt onconf(R).  {sqliteBeginTransaction(pParse,R);}
! trans_opt ::= .
! trans_opt ::= TRANSACTION.
! trans_opt ::= TRANSACTION nm.
! cmd ::= COMMIT trans_opt.      {sqliteCommitTransaction(pParse);}
! cmd ::= END trans_opt.         {sqliteCommitTransaction(pParse);}
! cmd ::= ROLLBACK trans_opt.    {sqliteRollbackTransaction(pParse);}
! 
! ///////////////////// The CREATE TABLE statement ////////////////////////////
! //
! cmd ::= create_table create_table_args.
! create_table ::= CREATE(X) temp(T) TABLE nm(Y). {
!    sqliteStartTable(pParse,&X,&Y,T,0);
! }
! %type temp {int}
! temp(A) ::= TEMP.  {A = 1;}
! temp(A) ::= .      {A = 0;}
! create_table_args ::= LP columnlist conslist_opt RP(X). {
!   sqliteEndTable(pParse,&X,0);
! }
! create_table_args ::= AS select(S). {
!   sqliteEndTable(pParse,0,S);
!   sqliteSelectDelete(S);
! }
! columnlist ::= columnlist COMMA column.
! columnlist ::= column.
! 
! // About the only information used for a column is the name of the
! // column.  The type is always just "text".  But the code will accept
! // an elaborate typename.  Perhaps someday we'll do something with it.
! //
! column ::= columnid type carglist. 
! columnid ::= nm(X).                {sqliteAddColumn(pParse,&X);}
! 
! // An IDENTIFIER can be a generic identifier, or one of several
! // keywords.  Any non-standard keyword can also be an identifier.
! //
! %type id {Token}
! id(A) ::= ID(X).         {A = X;}
! 
! // The following directive causes tokens ABORT, AFTER, ASC, etc. to
! // fallback to ID if they will not parse as their original value.
! // This obviates the need for the "id" nonterminal.
! //
! %fallback ID
!   ABORT AFTER ASC ATTACH BEFORE CASCADE CLUSTER CONFLICT
!   COPY DATABASE DEFERRED DELIMITERS DESC DETACH EACH EXPLAIN FAIL FOR
!   GLOB IGNORE IMMEDIATE INITIALLY INSTEAD LIKE MATCH KEY
!   OF OFFSET PRAGMA RAISE REPLACE RESTRICT ROW STATEMENT
!   TEMP TRIGGER VACUUM VIEW.
! 
! // Define operator precedence early so that this is the first occurance
! // of the operator tokens in the grammer.  Keeping the operators together
! // causes them to be assigned integer values that are close together,
! // which keeps parser tables smaller.
! //
! %left OR.
! %left AND.
! %right NOT.
! %left EQ NE ISNULL NOTNULL IS LIKE GLOB BETWEEN IN.
! %left GT GE LT LE.
! %left BITAND BITOR LSHIFT RSHIFT.
! %left PLUS MINUS.
! %left STAR SLASH REM.
! %left CONCAT.
! %right UMINUS UPLUS BITNOT.
! 
! // And "ids" is an identifer-or-string.
! //
! %type ids {Token}
! ids(A) ::= ID(X).        {A = X;}
! ids(A) ::= STRING(X).    {A = X;}
! 
! // The name of a column or table can be any of the following:
! //
! %type nm {Token}
! nm(A) ::= ID(X).         {A = X;}
! nm(A) ::= STRING(X).     {A = X;}
! nm(A) ::= JOIN_KW(X).    {A = X;}
! 
! type ::= .
! type ::= typename(X).                    {sqliteAddColumnType(pParse,&X,&X);}
! type ::= typename(X) LP signed RP(Y).    {sqliteAddColumnType(pParse,&X,&Y);}
! type ::= typename(X) LP signed COMMA signed RP(Y).
!                                          {sqliteAddColumnType(pParse,&X,&Y);}
! %type typename {Token}
! typename(A) ::= ids(X).           {A = X;}
! typename(A) ::= typename(X) ids.  {A = X;}
! %type signed {int}
! signed(A) ::= INTEGER(X).         { A = atoi(X.z); }
! signed(A) ::= PLUS INTEGER(X).    { A = atoi(X.z); }
! signed(A) ::= MINUS INTEGER(X).   { A = -atoi(X.z); }
! carglist ::= carglist carg.
! carglist ::= .
! carg ::= CONSTRAINT nm ccons.
! carg ::= ccons.
! carg ::= DEFAULT STRING(X).          {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT ID(X).              {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT INTEGER(X).         {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT PLUS INTEGER(X).    {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT MINUS INTEGER(X).   {sqliteAddDefaultValue(pParse,&X,1);}
! carg ::= DEFAULT FLOAT(X).           {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT PLUS FLOAT(X).      {sqliteAddDefaultValue(pParse,&X,0);}
! carg ::= DEFAULT MINUS FLOAT(X).     {sqliteAddDefaultValue(pParse,&X,1);}
! carg ::= DEFAULT NULL. 
! 
! // In addition to the type name, we also care about the primary key and
! // UNIQUE constraints.
! //
! ccons ::= NULL onconf.
! ccons ::= NOT NULL onconf(R).               {sqliteAddNotNull(pParse, R);}
! ccons ::= PRIMARY KEY sortorder onconf(R).  {sqliteAddPrimaryKey(pParse,0,R);}
! ccons ::= UNIQUE onconf(R).           {sqliteCreateIndex(pParse,0,0,0,R,0,0);}
! ccons ::= CHECK LP expr RP onconf.
! ccons ::= REFERENCES nm(T) idxlist_opt(TA) refargs(R).
!                                 {sqliteCreateForeignKey(pParse,0,&T,TA,R);}
! ccons ::= defer_subclause(D).   {sqliteDeferForeignKey(pParse,D);}
! ccons ::= COLLATE id(C).  {
!    sqliteAddCollateType(pParse, sqliteCollateType(C.z, C.n));
! }
! 
! // The next group of rules parses the arguments to a REFERENCES clause
! // that determine if the referential integrity checking is deferred or
! // or immediate and which determine what action to take if a ref-integ
! // check fails.
! //
! %type refargs {int}
! refargs(A) ::= .                     { A = OE_Restrict * 0x010101; }
! refargs(A) ::= refargs(X) refarg(Y). { A = (X & ~Y.mask) | Y.value; }
! %type refarg {struct {int value; int mask;}}
! refarg(A) ::= MATCH nm.              { A.value = 0;     A.mask = 0x000000; }
! refarg(A) ::= ON DELETE refact(X).   { A.value = X;     A.mask = 0x0000ff; }
! refarg(A) ::= ON UPDATE refact(X).   { A.value = X<<8;  A.mask = 0x00ff00; }
! refarg(A) ::= ON INSERT refact(X).   { A.value = X<<16; A.mask = 0xff0000; }
! %type refact {int}
! refact(A) ::= SET NULL.              { A = OE_SetNull; }
! refact(A) ::= SET DEFAULT.           { A = OE_SetDflt; }
! refact(A) ::= CASCADE.               { A = OE_Cascade; }
! refact(A) ::= RESTRICT.              { A = OE_Restrict; }
! %type defer_subclause {int}
! defer_subclause(A) ::= NOT DEFERRABLE init_deferred_pred_opt(X).  {A = X;}
! defer_subclause(A) ::= DEFERRABLE init_deferred_pred_opt(X).      {A = X;}
! %type init_deferred_pred_opt {int}
! init_deferred_pred_opt(A) ::= .                       {A = 0;}
! init_deferred_pred_opt(A) ::= INITIALLY DEFERRED.     {A = 1;}
! init_deferred_pred_opt(A) ::= INITIALLY IMMEDIATE.    {A = 0;}
! 
! // For the time being, the only constraint we care about is the primary
! // key and UNIQUE.  Both create indices.
! //
! conslist_opt ::= .
! conslist_opt ::= COMMA conslist.
! conslist ::= conslist COMMA tcons.
! conslist ::= conslist tcons.
! conslist ::= tcons.
! tcons ::= CONSTRAINT nm.
! tcons ::= PRIMARY KEY LP idxlist(X) RP onconf(R).
!                                              {sqliteAddPrimaryKey(pParse,X,R);}
! tcons ::= UNIQUE LP idxlist(X) RP onconf(R).
!                                        {sqliteCreateIndex(pParse,0,0,X,R,0,0);}
! tcons ::= CHECK expr onconf.
! tcons ::= FOREIGN KEY LP idxlist(FA) RP
!           REFERENCES nm(T) idxlist_opt(TA) refargs(R) defer_subclause_opt(D). {
!     sqliteCreateForeignKey(pParse, FA, &T, TA, R);
!     sqliteDeferForeignKey(pParse, D);
! }
! %type defer_subclause_opt {int}
! defer_subclause_opt(A) ::= .                    {A = 0;}
! defer_subclause_opt(A) ::= defer_subclause(X).  {A = X;}
! 
! // The following is a non-standard extension that allows us to declare the
! // default behavior when there is a constraint conflict.
! //
! %type onconf {int}
! %type orconf {int}
! %type resolvetype {int}
! onconf(A) ::= .                              { A = OE_Default; }
! onconf(A) ::= ON CONFLICT resolvetype(X).    { A = X; }
! orconf(A) ::= .                              { A = OE_Default; }
! orconf(A) ::= OR resolvetype(X).             { A = X; }
! resolvetype(A) ::= ROLLBACK.                 { A = OE_Rollback; }
! resolvetype(A) ::= ABORT.                    { A = OE_Abort; }
! resolvetype(A) ::= FAIL.                     { A = OE_Fail; }
! resolvetype(A) ::= IGNORE.                   { A = OE_Ignore; }
! resolvetype(A) ::= REPLACE.                  { A = OE_Replace; }
! 
! ////////////////////////// The DROP TABLE /////////////////////////////////////
! //
! cmd ::= DROP TABLE nm(X).          {sqliteDropTable(pParse,&X,0);}
! 
! ///////////////////// The CREATE VIEW statement /////////////////////////////
! //
! cmd ::= CREATE(X) temp(T) VIEW nm(Y) AS select(S). {
!   sqliteCreateView(pParse, &X, &Y, S, T);
! }
! cmd ::= DROP VIEW nm(X). {
!   sqliteDropTable(pParse, &X, 1);
! }
! 
! //////////////////////// The SELECT statement /////////////////////////////////
! //
! cmd ::= select(X).  {
!   sqliteSelect(pParse, X, SRT_Callback, 0, 0, 0, 0);
!   sqliteSelectDelete(X);
! }
! 
! %type select {Select*}
! %destructor select {sqliteSelectDelete($$);}
! %type oneselect {Select*}
! %destructor oneselect {sqliteSelectDelete($$);}
! 
! select(A) ::= oneselect(X).                      {A = X;}
! select(A) ::= select(X) multiselect_op(Y) oneselect(Z).  {
!   if( Z ){
!     Z->op = Y;
!     Z->pPrior = X;
!   }
!   A = Z;
! }
! %type multiselect_op {int}
! multiselect_op(A) ::= UNION.      {A = TK_UNION;}
! multiselect_op(A) ::= UNION ALL.  {A = TK_ALL;}
! multiselect_op(A) ::= INTERSECT.  {A = TK_INTERSECT;}
! multiselect_op(A) ::= EXCEPT.     {A = TK_EXCEPT;}
! oneselect(A) ::= SELECT distinct(D) selcollist(W) from(X) where_opt(Y)
!                  groupby_opt(P) having_opt(Q) orderby_opt(Z) limit_opt(L). {
!   A = sqliteSelectNew(W,X,Y,P,Q,Z,D,L.limit,L.offset);
! }
! 
! // The "distinct" nonterminal is true (1) if the DISTINCT keyword is
! // present and false (0) if it is not.
! //
! %type distinct {int}
! distinct(A) ::= DISTINCT.   {A = 1;}
! distinct(A) ::= ALL.        {A = 0;}
! distinct(A) ::= .           {A = 0;}
! 
! // selcollist is a list of expressions that are to become the return
! // values of the SELECT statement.  The "*" in statements like
! // "SELECT * FROM ..." is encoded as a special expression with an
! // opcode of TK_ALL.
! //
! %type selcollist {ExprList*}
! %destructor selcollist {sqliteExprListDelete($$);}
! %type sclp {ExprList*}
! %destructor sclp {sqliteExprListDelete($$);}
! sclp(A) ::= selcollist(X) COMMA.             {A = X;}
! sclp(A) ::= .                                {A = 0;}
! selcollist(A) ::= sclp(P) expr(X) as(Y).     {
!    A = sqliteExprListAppend(P,X,Y.n?&Y:0);
! }
! selcollist(A) ::= sclp(P) STAR. {
!   A = sqliteExprListAppend(P, sqliteExpr(TK_ALL, 0, 0, 0), 0);
! }
! selcollist(A) ::= sclp(P) nm(X) DOT STAR. {
!   Expr *pRight = sqliteExpr(TK_ALL, 0, 0, 0);
!   Expr *pLeft = sqliteExpr(TK_ID, 0, 0, &X);
!   A = sqliteExprListAppend(P, sqliteExpr(TK_DOT, pLeft, pRight, 0), 0);
! }
! 
! // An option "AS <id>" phrase that can follow one of the expressions that
! // define the result set, or one of the tables in the FROM clause.
! //
! %type as {Token}
! as(X) ::= AS nm(Y).    { X = Y; }
! as(X) ::= ids(Y).      { X = Y; }
! as(X) ::= .            { X.n = 0; }
! 
! 
! %type seltablist {SrcList*}
! %destructor seltablist {sqliteSrcListDelete($$);}
! %type stl_prefix {SrcList*}
! %destructor stl_prefix {sqliteSrcListDelete($$);}
! %type from {SrcList*}
! %destructor from {sqliteSrcListDelete($$);}
! 
! // A complete FROM clause.
! //
! from(A) ::= .                                 {A = sqliteMalloc(sizeof(*A));}
! from(A) ::= FROM seltablist(X).               {A = X;}
! 
! // "seltablist" is a "Select Table List" - the content of the FROM clause
! // in a SELECT statement.  "stl_prefix" is a prefix of this list.
! //
! stl_prefix(A) ::= seltablist(X) joinop(Y).    {
!    A = X;
!    if( A && A->nSrc>0 ) A->a[A->nSrc-1].jointype = Y;
! }
! stl_prefix(A) ::= .                           {A = 0;}
! seltablist(A) ::= stl_prefix(X) nm(Y) dbnm(D) as(Z) on_opt(N) using_opt(U). {
!   A = sqliteSrcListAppend(X,&Y,&D);
!   if( Z.n ) sqliteSrcListAddAlias(A,&Z);
!   if( N ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pOn = N; }
!     else { sqliteExprDelete(N); }
!   }
!   if( U ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pUsing = U; }
!     else { sqliteIdListDelete(U); }
!   }
! }
! seltablist(A) ::= stl_prefix(X) LP seltablist_paren(S) RP
!                   as(Z) on_opt(N) using_opt(U). {
!   A = sqliteSrcListAppend(X,0,0);
!   A->a[A->nSrc-1].pSelect = S;
!   if( Z.n ) sqliteSrcListAddAlias(A,&Z);
!   if( N ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pOn = N; }
!     else { sqliteExprDelete(N); }
!   }
!   if( U ){
!     if( A && A->nSrc>1 ){ A->a[A->nSrc-2].pUsing = U; }
!     else { sqliteIdListDelete(U); }
!   }
! }
! 
! // A seltablist_paren nonterminal represents anything in a FROM that
! // is contained inside parentheses.  This can be either a subquery or
! // a grouping of table and subqueries.
! //
! %type seltablist_paren {Select*}
! %destructor seltablist_paren {sqliteSelectDelete($$);}
! seltablist_paren(A) ::= select(S).      {A = S;}
! seltablist_paren(A) ::= seltablist(F).  {
!    A = sqliteSelectNew(0,F,0,0,0,0,0,-1,0);
! }
! 
! %type dbnm {Token}
! dbnm(A) ::= .          {A.z=0; A.n=0;}
! dbnm(A) ::= DOT nm(X). {A = X;}
! 
! %type joinop {int}
! %type joinop2 {int}
! joinop(X) ::= COMMA.                   { X = JT_INNER; }
! joinop(X) ::= JOIN.                    { X = JT_INNER; }
! joinop(X) ::= JOIN_KW(A) JOIN.         { X = sqliteJoinType(pParse,&A,0,0); }
! joinop(X) ::= JOIN_KW(A) nm(B) JOIN.   { X = sqliteJoinType(pParse,&A,&B,0); }
! joinop(X) ::= JOIN_KW(A) nm(B) nm(C) JOIN.
!                                        { X = sqliteJoinType(pParse,&A,&B,&C); }
! 
! %type on_opt {Expr*}
! %destructor on_opt {sqliteExprDelete($$);}
! on_opt(N) ::= ON expr(E).   {N = E;}
! on_opt(N) ::= .             {N = 0;}
! 
! %type using_opt {IdList*}
! %destructor using_opt {sqliteIdListDelete($$);}
! using_opt(U) ::= USING LP idxlist(L) RP.  {U = L;}
! using_opt(U) ::= .                        {U = 0;}
! 
! 
! %type orderby_opt {ExprList*}
! %destructor orderby_opt {sqliteExprListDelete($$);}
! %type sortlist {ExprList*}
! %destructor sortlist {sqliteExprListDelete($$);}
! %type sortitem {Expr*}
! %destructor sortitem {sqliteExprDelete($$);}
! 
! orderby_opt(A) ::= .                          {A = 0;}
! orderby_opt(A) ::= ORDER BY sortlist(X).      {A = X;}
! sortlist(A) ::= sortlist(X) COMMA sortitem(Y) collate(C) sortorder(Z). {
!   A = sqliteExprListAppend(X,Y,0);
!   if( A ) A->a[A->nExpr-1].sortOrder = C+Z;
! }
! sortlist(A) ::= sortitem(Y) collate(C) sortorder(Z). {
!   A = sqliteExprListAppend(0,Y,0);
!   if( A ) A->a[0].sortOrder = C+Z;
! }
! sortitem(A) ::= expr(X).   {A = X;}
! 
! %type sortorder {int}
! %type collate {int}
! 
! sortorder(A) ::= ASC.           {A = SQLITE_SO_ASC;}
! sortorder(A) ::= DESC.          {A = SQLITE_SO_DESC;}
! sortorder(A) ::= .              {A = SQLITE_SO_ASC;}
! collate(C) ::= .                {C = SQLITE_SO_UNK;}
! collate(C) ::= COLLATE id(X).   {C = sqliteCollateType(X.z, X.n);}
! 
! %type groupby_opt {ExprList*}
! %destructor groupby_opt {sqliteExprListDelete($$);}
! groupby_opt(A) ::= .                      {A = 0;}
! groupby_opt(A) ::= GROUP BY exprlist(X).  {A = X;}
! 
! %type having_opt {Expr*}
! %destructor having_opt {sqliteExprDelete($$);}
! having_opt(A) ::= .                {A = 0;}
! having_opt(A) ::= HAVING expr(X).  {A = X;}
! 
! %type limit_opt {struct LimitVal}
! limit_opt(A) ::= .                     {A.limit = -1; A.offset = 0;}
! limit_opt(A) ::= LIMIT signed(X).      {A.limit = X; A.offset = 0;}
! limit_opt(A) ::= LIMIT signed(X) OFFSET signed(Y). 
!                                        {A.limit = X; A.offset = Y;}
! limit_opt(A) ::= LIMIT signed(X) COMMA signed(Y). 
!                                        {A.limit = Y; A.offset = X;}
! 
! /////////////////////////// The DELETE statement /////////////////////////////
! //
! cmd ::= DELETE FROM nm(X) dbnm(D) where_opt(Y). {
!    sqliteDeleteFrom(pParse, sqliteSrcListAppend(0,&X,&D), Y);
! }
! 
! %type where_opt {Expr*}
! %destructor where_opt {sqliteExprDelete($$);}
! 
! where_opt(A) ::= .                    {A = 0;}
! where_opt(A) ::= WHERE expr(X).       {A = X;}
! 
! %type setlist {ExprList*}
! %destructor setlist {sqliteExprListDelete($$);}
! 
! ////////////////////////// The UPDATE command ////////////////////////////////
! //
! cmd ::= UPDATE orconf(R) nm(X) dbnm(D) SET setlist(Y) where_opt(Z).
!     {sqliteUpdate(pParse,sqliteSrcListAppend(0,&X,&D),Y,Z,R);}
! 
! setlist(A) ::= setlist(Z) COMMA nm(X) EQ expr(Y).
!     {A = sqliteExprListAppend(Z,Y,&X);}
! setlist(A) ::= nm(X) EQ expr(Y).   {A = sqliteExprListAppend(0,Y,&X);}
! 
! ////////////////////////// The INSERT command /////////////////////////////////
! //
! cmd ::= insert_cmd(R) INTO nm(X) dbnm(D) inscollist_opt(F) 
!         VALUES LP itemlist(Y) RP.
!             {sqliteInsert(pParse, sqliteSrcListAppend(0,&X,&D), Y, 0, F, R);}
! cmd ::= insert_cmd(R) INTO nm(X) dbnm(D) inscollist_opt(F) select(S).
!             {sqliteInsert(pParse, sqliteSrcListAppend(0,&X,&D), 0, S, F, R);}
! 
! %type insert_cmd {int}
! insert_cmd(A) ::= INSERT orconf(R).   {A = R;}
! insert_cmd(A) ::= REPLACE.            {A = OE_Replace;}
! 
! 
! %type itemlist {ExprList*}
! %destructor itemlist {sqliteExprListDelete($$);}
! 
! itemlist(A) ::= itemlist(X) COMMA expr(Y).  {A = sqliteExprListAppend(X,Y,0);}
! itemlist(A) ::= expr(X).                    {A = sqliteExprListAppend(0,X,0);}
! 
! %type inscollist_opt {IdList*}
! %destructor inscollist_opt {sqliteIdListDelete($$);}
! %type inscollist {IdList*}
! %destructor inscollist {sqliteIdListDelete($$);}
! 
! inscollist_opt(A) ::= .                       {A = 0;}
! inscollist_opt(A) ::= LP inscollist(X) RP.    {A = X;}
! inscollist(A) ::= inscollist(X) COMMA nm(Y).  {A = sqliteIdListAppend(X,&Y);}
! inscollist(A) ::= nm(Y).                      {A = sqliteIdListAppend(0,&Y);}
! 
! /////////////////////////// Expression Processing /////////////////////////////
! //
! 
! %type expr {Expr*}
! %destructor expr {sqliteExprDelete($$);}
! 
! expr(A) ::= LP(B) expr(X) RP(E). {A = X; sqliteExprSpan(A,&B,&E); }
! expr(A) ::= NULL(X).             {A = sqliteExpr(TK_NULL, 0, 0, &X);}
! expr(A) ::= ID(X).               {A = sqliteExpr(TK_ID, 0, 0, &X);}
! expr(A) ::= JOIN_KW(X).          {A = sqliteExpr(TK_ID, 0, 0, &X);}
! expr(A) ::= nm(X) DOT nm(Y). {
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   Expr *temp2 = sqliteExpr(TK_ID, 0, 0, &Y);
!   A = sqliteExpr(TK_DOT, temp1, temp2, 0);
! }
! expr(A) ::= nm(X) DOT nm(Y) DOT nm(Z). {
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   Expr *temp2 = sqliteExpr(TK_ID, 0, 0, &Y);
!   Expr *temp3 = sqliteExpr(TK_ID, 0, 0, &Z);
!   Expr *temp4 = sqliteExpr(TK_DOT, temp2, temp3, 0);
!   A = sqliteExpr(TK_DOT, temp1, temp4, 0);
! }
! expr(A) ::= INTEGER(X).      {A = sqliteExpr(TK_INTEGER, 0, 0, &X);}
! expr(A) ::= FLOAT(X).        {A = sqliteExpr(TK_FLOAT, 0, 0, &X);}
! expr(A) ::= STRING(X).       {A = sqliteExpr(TK_STRING, 0, 0, &X);}
! expr(A) ::= VARIABLE(X).     {
!   A = sqliteExpr(TK_VARIABLE, 0, 0, &X);
!   if( A ) A->iTable = ++pParse->nVar;
! }
! expr(A) ::= ID(X) LP exprlist(Y) RP(E). {
!   A = sqliteExprFunction(Y, &X);
!   sqliteExprSpan(A,&X,&E);
! }
! expr(A) ::= ID(X) LP STAR RP(E). {
!   A = sqliteExprFunction(0, &X);
!   sqliteExprSpan(A,&X,&E);
! }
! expr(A) ::= expr(X) AND expr(Y).   {A = sqliteExpr(TK_AND, X, Y, 0);}
! expr(A) ::= expr(X) OR expr(Y).    {A = sqliteExpr(TK_OR, X, Y, 0);}
! expr(A) ::= expr(X) LT expr(Y).    {A = sqliteExpr(TK_LT, X, Y, 0);}
! expr(A) ::= expr(X) GT expr(Y).    {A = sqliteExpr(TK_GT, X, Y, 0);}
! expr(A) ::= expr(X) LE expr(Y).    {A = sqliteExpr(TK_LE, X, Y, 0);}
! expr(A) ::= expr(X) GE expr(Y).    {A = sqliteExpr(TK_GE, X, Y, 0);}
! expr(A) ::= expr(X) NE expr(Y).    {A = sqliteExpr(TK_NE, X, Y, 0);}
! expr(A) ::= expr(X) EQ expr(Y).    {A = sqliteExpr(TK_EQ, X, Y, 0);}
! expr(A) ::= expr(X) BITAND expr(Y). {A = sqliteExpr(TK_BITAND, X, Y, 0);}
! expr(A) ::= expr(X) BITOR expr(Y).  {A = sqliteExpr(TK_BITOR, X, Y, 0);}
! expr(A) ::= expr(X) LSHIFT expr(Y). {A = sqliteExpr(TK_LSHIFT, X, Y, 0);}
! expr(A) ::= expr(X) RSHIFT expr(Y). {A = sqliteExpr(TK_RSHIFT, X, Y, 0);}
! expr(A) ::= expr(X) likeop(OP) expr(Y).  [LIKE]  {
!   ExprList *pList = sqliteExprListAppend(0, Y, 0);
!   pList = sqliteExprListAppend(pList, X, 0);
!   A = sqliteExprFunction(pList, 0);
!   if( A ) A->op = OP;
!   sqliteExprSpan(A, &X->span, &Y->span);
! }
! expr(A) ::= expr(X) NOT likeop(OP) expr(Y). [LIKE] {
!   ExprList *pList = sqliteExprListAppend(0, Y, 0);
!   pList = sqliteExprListAppend(pList, X, 0);
!   A = sqliteExprFunction(pList, 0);
!   if( A ) A->op = OP;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,&Y->span);
! }
! %type likeop {int}
! likeop(A) ::= LIKE. {A = TK_LIKE;}
! likeop(A) ::= GLOB. {A = TK_GLOB;}
! expr(A) ::= expr(X) PLUS expr(Y).  {A = sqliteExpr(TK_PLUS, X, Y, 0);}
! expr(A) ::= expr(X) MINUS expr(Y). {A = sqliteExpr(TK_MINUS, X, Y, 0);}
! expr(A) ::= expr(X) STAR expr(Y).  {A = sqliteExpr(TK_STAR, X, Y, 0);}
! expr(A) ::= expr(X) SLASH expr(Y). {A = sqliteExpr(TK_SLASH, X, Y, 0);}
! expr(A) ::= expr(X) REM expr(Y).   {A = sqliteExpr(TK_REM, X, Y, 0);}
! expr(A) ::= expr(X) CONCAT expr(Y). {A = sqliteExpr(TK_CONCAT, X, Y, 0);}
! expr(A) ::= expr(X) ISNULL(E). {
!   A = sqliteExpr(TK_ISNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IS NULL(E). {
!   A = sqliteExpr(TK_ISNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOTNULL(E). {
!   A = sqliteExpr(TK_NOTNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOT NULL(E). {
!   A = sqliteExpr(TK_NOTNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IS NOT NULL(E). {
!   A = sqliteExpr(TK_NOTNULL, X, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= NOT(B) expr(X). {
!   A = sqliteExpr(TK_NOT, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= BITNOT(B) expr(X). {
!   A = sqliteExpr(TK_BITNOT, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= MINUS(B) expr(X). [UMINUS] {
!   A = sqliteExpr(TK_UMINUS, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= PLUS(B) expr(X). [UPLUS] {
!   A = sqliteExpr(TK_UPLUS, X, 0, 0);
!   sqliteExprSpan(A,&B,&X->span);
! }
! expr(A) ::= LP(B) select(X) RP(E). {
!   A = sqliteExpr(TK_SELECT, 0, 0, 0);
!   if( A ) A->pSelect = X;
!   sqliteExprSpan(A,&B,&E);
! }
! expr(A) ::= expr(W) BETWEEN expr(X) AND expr(Y). {
!   ExprList *pList = sqliteExprListAppend(0, X, 0);
!   pList = sqliteExprListAppend(pList, Y, 0);
!   A = sqliteExpr(TK_BETWEEN, W, 0, 0);
!   if( A ) A->pList = pList;
!   sqliteExprSpan(A,&W->span,&Y->span);
! }
! expr(A) ::= expr(W) NOT BETWEEN expr(X) AND expr(Y). {
!   ExprList *pList = sqliteExprListAppend(0, X, 0);
!   pList = sqliteExprListAppend(pList, Y, 0);
!   A = sqliteExpr(TK_BETWEEN, W, 0, 0);
!   if( A ) A->pList = pList;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&W->span,&Y->span);
! }
! expr(A) ::= expr(X) IN LP exprlist(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pList = Y;
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IN LP select(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = Y;
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOT IN LP exprlist(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pList = Y;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) NOT IN LP select(Y) RP(E).  {
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = Y;
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,&E);
! }
! expr(A) ::= expr(X) IN nm(Y) dbnm(D). {
!   SrcList *pSrc = sqliteSrcListAppend(0, &Y, &D);
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = sqliteSelectNew(0,pSrc,0,0,0,0,0,-1,0);
!   sqliteExprSpan(A,&X->span,D.z?&D:&Y);
! }
! expr(A) ::= expr(X) NOT IN nm(Y) dbnm(D). {
!   SrcList *pSrc = sqliteSrcListAppend(0, &Y, &D);
!   A = sqliteExpr(TK_IN, X, 0, 0);
!   if( A ) A->pSelect = sqliteSelectNew(0,pSrc,0,0,0,0,0,-1,0);
!   A = sqliteExpr(TK_NOT, A, 0, 0);
!   sqliteExprSpan(A,&X->span,D.z?&D:&Y);
! }
! 
! /* CASE expressions */
! expr(A) ::= CASE(C) case_operand(X) case_exprlist(Y) case_else(Z) END(E). {
!   A = sqliteExpr(TK_CASE, X, Z, 0);
!   if( A ) A->pList = Y;
!   sqliteExprSpan(A, &C, &E);
! }
! %type case_exprlist {ExprList*}
! %destructor case_exprlist {sqliteExprListDelete($$);}
! case_exprlist(A) ::= case_exprlist(X) WHEN expr(Y) THEN expr(Z). {
!   A = sqliteExprListAppend(X, Y, 0);
!   A = sqliteExprListAppend(A, Z, 0);
! }
! case_exprlist(A) ::= WHEN expr(Y) THEN expr(Z). {
!   A = sqliteExprListAppend(0, Y, 0);
!   A = sqliteExprListAppend(A, Z, 0);
! }
! %type case_else {Expr*}
! case_else(A) ::=  ELSE expr(X).         {A = X;}
! case_else(A) ::=  .                     {A = 0;} 
! %type case_operand {Expr*}
! case_operand(A) ::= expr(X).            {A = X;} 
! case_operand(A) ::= .                   {A = 0;} 
! 
! %type exprlist {ExprList*}
! %destructor exprlist {sqliteExprListDelete($$);}
! %type expritem {Expr*}
! %destructor expritem {sqliteExprDelete($$);}
! 
! exprlist(A) ::= exprlist(X) COMMA expritem(Y). 
!    {A = sqliteExprListAppend(X,Y,0);}
! exprlist(A) ::= expritem(X).            {A = sqliteExprListAppend(0,X,0);}
! expritem(A) ::= expr(X).                {A = X;}
! expritem(A) ::= .                       {A = 0;}
! 
! ///////////////////////////// The CREATE INDEX command ///////////////////////
! //
! cmd ::= CREATE(S) uniqueflag(U) INDEX nm(X)
!         ON nm(Y) dbnm(D) LP idxlist(Z) RP(E) onconf(R). {
!   SrcList *pSrc = sqliteSrcListAppend(0, &Y, &D);
!   if( U!=OE_None ) U = R;
!   if( U==OE_Default) U = OE_Abort;
!   sqliteCreateIndex(pParse, &X, pSrc, Z, U, &S, &E);
! }
! 
! %type uniqueflag {int}
! uniqueflag(A) ::= UNIQUE.  { A = OE_Abort; }
! uniqueflag(A) ::= .        { A = OE_None; }
! 
! %type idxlist {IdList*}
! %destructor idxlist {sqliteIdListDelete($$);}
! %type idxlist_opt {IdList*}
! %destructor idxlist_opt {sqliteIdListDelete($$);}
! %type idxitem {Token}
! 
! idxlist_opt(A) ::= .                         {A = 0;}
! idxlist_opt(A) ::= LP idxlist(X) RP.         {A = X;}
! idxlist(A) ::= idxlist(X) COMMA idxitem(Y).  {A = sqliteIdListAppend(X,&Y);}
! idxlist(A) ::= idxitem(Y).                   {A = sqliteIdListAppend(0,&Y);}
! idxitem(A) ::= nm(X) sortorder.              {A = X;}
! 
! ///////////////////////////// The DROP INDEX command /////////////////////////
! //
! 
! cmd ::= DROP INDEX nm(X) dbnm(Y).   {
!   sqliteDropIndex(pParse, sqliteSrcListAppend(0,&X,&Y));
! }
! 
! 
! ///////////////////////////// The COPY command ///////////////////////////////
! //
! cmd ::= COPY orconf(R) nm(X) dbnm(D) FROM nm(Y) USING DELIMITERS STRING(Z).
!     {sqliteCopy(pParse,sqliteSrcListAppend(0,&X,&D),&Y,&Z,R);}
! cmd ::= COPY orconf(R) nm(X) dbnm(D) FROM nm(Y).
!     {sqliteCopy(pParse,sqliteSrcListAppend(0,&X,&D),&Y,0,R);}
! 
! ///////////////////////////// The VACUUM command /////////////////////////////
! //
! cmd ::= VACUUM.                {sqliteVacuum(pParse,0);}
! cmd ::= VACUUM nm(X).         {sqliteVacuum(pParse,&X);}
! 
! ///////////////////////////// The PRAGMA command /////////////////////////////
! //
! cmd ::= PRAGMA ids(X) EQ nm(Y).         {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X) EQ ON(Y).          {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X) EQ plus_num(Y).    {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X) EQ minus_num(Y).   {sqlitePragma(pParse,&X,&Y,1);}
! cmd ::= PRAGMA ids(X) LP nm(Y) RP.      {sqlitePragma(pParse,&X,&Y,0);}
! cmd ::= PRAGMA ids(X).                   {sqlitePragma(pParse,&X,&X,0);}
! plus_num(A) ::= plus_opt number(X).   {A = X;}
! minus_num(A) ::= MINUS number(X).     {A = X;}
! number(A) ::= INTEGER(X).  {A = X;}
! number(A) ::= FLOAT(X).    {A = X;}
! plus_opt ::= PLUS.
! plus_opt ::= .
! 
! //////////////////////////// The CREATE TRIGGER command /////////////////////
! 
! cmd ::= CREATE(A) trigger_decl BEGIN trigger_cmd_list(S) END(Z). {
!   Token all;
!   all.z = A.z;
!   all.n = (Z.z - A.z) + Z.n;
!   sqliteFinishTrigger(pParse, S, &all);
! }
! 
! trigger_decl ::= temp(T) TRIGGER nm(B) trigger_time(C) trigger_event(D)
!                  ON nm(E) dbnm(DB) foreach_clause(F) when_clause(G). {
!   SrcList *pTab = sqliteSrcListAppend(0, &E, &DB);
!   sqliteBeginTrigger(pParse, &B, C, D.a, D.b, pTab, F, G, T);
! }
! 
! %type trigger_time  {int}
! trigger_time(A) ::= BEFORE.      { A = TK_BEFORE; }
! trigger_time(A) ::= AFTER.       { A = TK_AFTER;  }
! trigger_time(A) ::= INSTEAD OF.  { A = TK_INSTEAD;}
! trigger_time(A) ::= .            { A = TK_BEFORE; }
! 
! %type trigger_event {struct TrigEvent}
! %destructor trigger_event {sqliteIdListDelete($$.b);}
! trigger_event(A) ::= DELETE. { A.a = TK_DELETE; A.b = 0; }
! trigger_event(A) ::= INSERT. { A.a = TK_INSERT; A.b = 0; }
! trigger_event(A) ::= UPDATE. { A.a = TK_UPDATE; A.b = 0;}
! trigger_event(A) ::= UPDATE OF inscollist(X). {A.a = TK_UPDATE; A.b = X; }
! 
! %type foreach_clause {int}
! foreach_clause(A) ::= .                   { A = TK_ROW; }
! foreach_clause(A) ::= FOR EACH ROW.       { A = TK_ROW; }
! foreach_clause(A) ::= FOR EACH STATEMENT. { A = TK_STATEMENT; }
! 
! %type when_clause {Expr *}
! when_clause(A) ::= .             { A = 0; }
! when_clause(A) ::= WHEN expr(X). { A = X; }
! 
! %type trigger_cmd_list {TriggerStep *}
! %destructor trigger_cmd_list {sqliteDeleteTriggerStep($$);}
! trigger_cmd_list(A) ::= trigger_cmd(X) SEMI trigger_cmd_list(Y). {
!   X->pNext = Y;
!   A = X;
! }
! trigger_cmd_list(A) ::= . { A = 0; }
! 
! %type trigger_cmd {TriggerStep *}
! %destructor trigger_cmd {sqliteDeleteTriggerStep($$);}
! // UPDATE 
! trigger_cmd(A) ::= UPDATE orconf(R) nm(X) SET setlist(Y) where_opt(Z).  
!                { A = sqliteTriggerUpdateStep(&X, Y, Z, R); }
! 
! // INSERT
! trigger_cmd(A) ::= insert_cmd(R) INTO nm(X) inscollist_opt(F) 
!   VALUES LP itemlist(Y) RP.  
! {A = sqliteTriggerInsertStep(&X, F, Y, 0, R);}
! 
! trigger_cmd(A) ::= insert_cmd(R) INTO nm(X) inscollist_opt(F) select(S).
!                {A = sqliteTriggerInsertStep(&X, F, 0, S, R);}
! 
! // DELETE
! trigger_cmd(A) ::= DELETE FROM nm(X) where_opt(Y).
!                {A = sqliteTriggerDeleteStep(&X, Y);}
! 
! // SELECT
! trigger_cmd(A) ::= select(X).  {A = sqliteTriggerSelectStep(X); }
! 
! // The special RAISE expression that may occur in trigger programs
! expr(A) ::= RAISE(X) LP IGNORE RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, 0); 
!   A->iColumn = OE_Ignore;
!   sqliteExprSpan(A, &X, &Y);
! }
! expr(A) ::= RAISE(X) LP ROLLBACK COMMA nm(Z) RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, &Z); 
!   A->iColumn = OE_Rollback;
!   sqliteExprSpan(A, &X, &Y);
! }
! expr(A) ::= RAISE(X) LP ABORT COMMA nm(Z) RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, &Z); 
!   A->iColumn = OE_Abort;
!   sqliteExprSpan(A, &X, &Y);
! }
! expr(A) ::= RAISE(X) LP FAIL COMMA nm(Z) RP(Y).  {
!   A = sqliteExpr(TK_RAISE, 0, 0, &Z); 
!   A->iColumn = OE_Fail;
!   sqliteExprSpan(A, &X, &Y);
! }
! 
! ////////////////////////  DROP TRIGGER statement //////////////////////////////
! cmd ::= DROP TRIGGER nm(X) dbnm(D). {
!   sqliteDropTrigger(pParse,sqliteSrcListAppend(0,&X,&D));
! }
! 
! //////////////////////// ATTACH DATABASE file AS name /////////////////////////
! cmd ::= ATTACH database_kw_opt ids(F) AS nm(D) key_opt(K). {
!   sqliteAttach(pParse, &F, &D, &K);
! }
! %type key_opt {Token}
! key_opt(A) ::= USING ids(X).  { A = X; }
! key_opt(A) ::= .              { A.z = 0; A.n = 0; }
! 
! database_kw_opt ::= DATABASE.
! database_kw_opt ::= .
! 
! //////////////////////// DETACH DATABASE name /////////////////////////////////
! cmd ::= DETACH database_kw_opt nm(D). {
!   sqliteDetach(pParse, &D);
! }
! 
! ////////////////////////// PROCEDURAL LANGUAGE /////////////////////////////////
! //
! 
! %type block {Block*}
! %destructor block {sqliteBlockDelete($$);}
! 
! block(A) ::= blockinit proc_locals_opt BEGIN stmtlist(X) SEMI excep_opt(Y) END.
! 											{A = sqliteEndBlock(pParse, X, Y);}
! 
! blockinit ::= . {sqliteStartBlock(pParse, 0);}
! 
! // local variables
! 
! proc_locals_opt ::= DECLARE varlist.
! proc_locals_opt ::= .
! 
! varlist ::= varlist var_decl.
! varlist ::= var_decl.
! 
! var_decl ::= var_id localvar_type notnull_opt init_decl_opt SEMI.
! 
! var_id ::= nm(X).							 {sqliteAddProcVar(pParse,&X);}
! 
! init_decl_opt ::= COLON EQ expr(X).  {sqliteAddProcVarExpr(pParse, X, 0);}
! init_decl_opt ::= DEFAULT expr(X).   {sqliteAddProcVarExpr(pParse, X, 0);}
! init_decl_opt ::= .
! 
! notnull_opt ::= NOT NULL.  {sqliteAddProcVarExpr(pParse, 0, 1);}
! notnull_opt ::= .
! 
! localvar_type ::= .
! localvar_type ::= typename(X).                    {sqliteAddProcVarType(pParse,&X,&X);}
! localvar_type ::= typename(X) LP signed RP(Y).    {sqliteAddProcVarType(pParse,&X,&Y);}
! localvar_type ::= typename(X) LP signed COMMA signed RP(Y).
! 												  {sqliteAddProcVarType(pParse,&X,&Y);}
! // exception handlers
! 
! %type excep_opt {StmtList*}
! %destructor excep_opt {sqliteStmtListDelete($$);}
! 
! excep_opt(A) ::= EXCEPTION whenlist(X).  {A = X;}
! excep_opt(A) ::= .                       {A = 0;}
! 
! %type excep {Expr*}
! %destructor excep {sqliteExprDelete($$);}
! 
! excep(A) ::= nm(X).					{A = sqliteExpr(TK_ID, 0, 0, &X);}
! excep(A) ::= excep(X) OR excep(Y).  {A = sqliteExpr(TK_OR, X, Y, 0);}
! 
! %type whenlist {StmtList*}
! %destructor whenlist {sqliteStmtListDelete($$);}
! %type whenitem {Stmt*}
! %destructor whenitem {sqliteStmtDelete($$);}
! 
! whenlist(A) ::= whenlist(X) whenitem(Y).             {A = sqliteStmtListAppend(X,Y);}
! whenlist(A) ::= whenitem(X).                         {A = sqliteStmtListAppend(0,X);}
! whenitem(A) ::= WHEN excep(X) THEN stmtlist(Y) SEMI. {A = sqliteStmt(pParse,TK_WHEN,X,Y,0,0);}
! whenitem(A) ::= WHEN OTHERS THEN stmtlist(Y) SEMI.   {A = sqliteStmt(pParse,TK_WHEN,0,Y,0,0);}
! 
! // statements
! 
! %type stmtlist {StmtList*}
! %destructor stmtlist {sqliteStmtListDelete($$);}
! %type stmtitem {Stmt*}
! %destructor stmtitem {sqliteStmtDelete($$);}
! %type stmt {Stmt*}
! %destructor stmt {sqliteStmtDelete($$);}
! 
! stmtlist(A) ::= stmtlist(X) SEMI stmtitem(Y). {A = sqliteStmtListAppend(X,Y);}
! stmtlist(A) ::= stmtitem(X).                  {A = sqliteStmtListAppend(0,X);}
! stmtitem(A) ::= stmt(X).                      {A = X;}
! 
! // IF - THEN - ELSIF - ELSE - END IF
! 
! %type else_opt {Stmt*}
! %destructor else_opt {sqliteStmtDelete($$);}
! 
! else_opt(A) ::= ELSE stmtlist(Y) SEMI else_opt(Z). {
!   A = sqliteStmt(pParse,TK_ELSE,0,Y,Z,0);
! }
! else_opt(A) ::= ELSIF expr(X) THEN stmtlist(Y) SEMI else_opt(Z). {
!   A = sqliteStmt(pParse,TK_ELSIF,X,Y,Z,0);
! }
! else_opt(A) ::= END IF.    { A = 0; }
! 
! stmt(A) ::= IF expr(X) THEN stmtlist(Y) SEMI else_opt(Z). {
!   A = sqliteStmt(pParse,TK_IF,X,Y,Z,0);
! }
! 
! // WHILE, FOR, LOOP .. END LOOP
! 
! %type loop {StmtList*}
! %destructor loop {sqliteStmtListDelete($$);}
! 
! loop(A) ::= LOOP stmtlist(Y) SEMI END LOOP.    { A = Y; }
! 
! stmt(A) ::= loop(Y). {
!   A = sqliteStmt(pParse,TK_LOOP,0,Y,0,0);
! }
! stmt(A) ::= WHILE expr(X) loop(Y). {
!   A = sqliteStmt(pParse,TK_WHILE,X,Y,0,0);
! }
! stmt(A) ::= FOR nm(N) IN expr(L) DOTDOT expr(U) loop(Y).	{
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &N);
!   Expr *temp2 = sqliteExpr(TK_FOR, L, U, 0);
!   Expr *temp3 = sqliteExpr(TK_ASSIGN, temp1, temp2, 0);
!   A = sqliteStmt(pParse,TK_FOR,temp3,Y,0,0);
! }
! 
! // CASE WHEN ELSE END CASE
! 
! stmt(A) ::= CASE case_operand(X) caselist(Y) END CASE. {
!   A = sqliteStmt(pParse,TK_CASE,X,Y,0,0);
! }
! stmt(A) ::= CASE case_operand(X) caselist(Y) ELSE stmtlist(Z) SEMI END CASE. {
!   Stmt *pStmt = sqliteStmt(pParse,TK_ELSE,0,Z,0,0);
!   A = sqliteStmt(pParse,TK_CASE,X,Y,pStmt,0);
! }
! 
! %type caselist {StmtList*}
! %destructor caselist {sqliteStmtListDelete($$);}
! %type caseitem {Stmt*}
! %destructor caseitem {sqliteStmtDelete($$);}
! caselist(A) ::= caselist(X) caseitem(Y).            {A = sqliteStmtListAppend(X,Y);}
! caselist(A) ::= caseitem(X).                        {A = sqliteStmtListAppend(0,X);}
! caseitem(A) ::= WHEN expr(X) THEN stmtlist(Y) SEMI. {A = sqliteStmt(pParse,TK_WHEN,X,Y,0,0);}
! 
! // Starting with ID: assignment & procedure call
! 
! stmt(A) ::= nm(X) COLON EQ expr(Y).	{
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   Expr *temp2 = sqliteExpr(TK_ASSIGN, temp1, Y, 0);
!   A = sqliteStmt(pParse,TK_ASSIGN,temp2,0,0,0);
! }
! stmt(A) ::= nm(X) LP exprlist(E) RP. {
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   temp1->pList = E;
!   A = sqliteStmt(pParse,TK_PROCEDURE,temp1,0,0,0);
! }
! stmt(A) ::= nm(X) . {
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   A = sqliteStmt(pParse,TK_PROCEDURE,temp1,0,0,0);
! }
! 
! // simple statements
! 
! stmt(A) ::= NULL.						{A = sqliteStmt(pParse,TK_NULL,0,0,0,0);}
! stmt(A) ::= PRINT expr(X).				{A = sqliteStmt(pParse,TK_PRINT,X,0,0,0);}
! stmt(A) ::= EXIT WHEN expr(X).			{A = sqliteStmt(pParse,TK_EXIT,X,0,0,0);}
! stmt(A) ::= EXIT.						{A = sqliteStmt(pParse,TK_EXIT,0,0,0,0);}
! stmt(A) ::= RETURN expr(X).				{A = sqliteStmt(pParse,TK_RETURN,X,0,0,0);}
! stmt(A) ::= RETURN.	{
!   Expr *temp1 = sqliteExpr(TK_NULL, 0, 0, 0);
!   A = sqliteStmt(pParse,TK_RETURN,temp1,0,0,0);
! }
! stmt(A) ::= RAISE.						{A = sqliteStmt(pParse,TK_RAISE,0,0,0,0);}
! stmt(A) ::= RAISE nm(X). {
!   Expr *temp1 = sqliteExpr(TK_ID, 0, 0, &X);
!   A = sqliteStmt(pParse,TK_RAISE,temp1,0,0,0);
! }
! 
! stmt(A) ::= block(X).					{A = sqliteStmt(pParse,TK_BLOCK,0,0,0,X);}
! 
! // SQL statements
! 
! stmt(A) ::= SELECT distinct(D) selcollist(W) INTO itemlist(Y) from(X) where_opt(K)
!                  groupby_opt(P) having_opt(Q) orderby_opt(Z) limit_opt(L). {
!   Select* ss = sqliteSelectNew(W,X,K,P,Q,Z,D,L.limit,L.offset);
!   A = sqliteSQLStmt(TK_SELECT, 0, 0, Y, ss, 0, 0);
! }
! stmt(A) ::= insert_cmd(R) INTO nm(X) inscollist_opt(F) VALUES LP itemlist(Y) RP.  {
!   A = sqliteSQLStmt(TK_INSERT, &X, F, Y, 0, 0, R);
! }
! stmt(A) ::= insert_cmd(R) INTO nm(X) inscollist_opt(F) select(S). {
!   A = sqliteSQLStmt(TK_INSERT, &X, F, 0, S, 0, R);
! }
! stmt(A) ::= UPDATE orconf(R) nm(X) SET setlist(Y) where_opt(Z).  {
!   A = sqliteSQLStmt(TK_UPDATE, &X, 0, Y, 0, Z, R);
! }
! stmt(A) ::= DELETE FROM nm(X) where_opt(Z).	{
!   A = sqliteSQLStmt(TK_DELETE, &X, 0, 0, 0, Z, 0);
! }
! 
! ////////////////////////// CREATE/DROP PROCEDURE and FUNCTION ////////////////////////
! //
! 
! cmd ::= CREATE(A) proc_decl proc_locals_opt BEGIN stmtlist(X) SEMI excep_opt(Y) END(Z). {
!   Token all;
!   all.z = A.z;
!   all.n = (Z.z - A.z) + Z.n;
!   sqliteFinishProc(pParse, sqliteEndBlock(pParse,X,Y), &all);
! }
! 
! proc_decl ::= kw_proc nm(B) LP paramlist RP AS. {
!   sqliteBeginProc(pParse, TK_PROCEDURE, &B);
! }
! 
! kw_proc ::= PROCEDURE.		{sqliteStartBlock(pParse, 1);}
! 
! paramlist ::= paramlist COMMA param_decl.
! paramlist ::= param_decl.
! paramlist ::= .
! 
! param_decl ::= var_id localvar_type.
! 
! cmd ::= DROP PROCEDURE nm(X).		{ sqliteDropProc(pParse, &X); }
! 
! ////////////////////////// DIRECT EXECUTION /////////////////////////////////
! //
! 
! cmd ::= EXEC PROCEDURE nm(X) LP exprlist(E) RP.		{ sqliteExecProc(pParse, &X, E);}
! cmd ::= EXEC PROCEDURE nm(X).                 		{ sqliteExecProc(pParse, &X, 0);}
! 
! cmd ::= EXEC block(B).	{sqliteExecBlock(pParse, B);}
! 
Only in src/: proc.c
Only in src/: refinteg.c
diff -c ../sqlite-2.8.17/src/select.c src/select.c
*** ../sqlite-2.8.17/src/select.c	2005-04-23 18:43:22.000000000 -0400
--- src/select.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 532,537 ****
--- 532,549 ----
        break;
      }
  
+     /* If this is a "select into", then leave the results on the
+ 	** stack and break out of the loop.
+     */
+ 	case SRT_Stack: {
+       if( pOrderBy ){
+         pushOntoSorter(pParse, v, pOrderBy);
+       }else{
+         sqliteVdbeAddOp(v, OP_Goto, 0, iBreak);
+       }
+       break;
+     }
+ 
      /* Send the data to the callback function.
      */
      case SRT_Callback:
***************
*** 614,619 ****
--- 626,635 ----
        sqliteVdbeAddOp(v, OP_PutStrKey, iParm, 0);
        break;
      }
+ 	case SRT_Stack: {
+       sqliteVdbeAddOp(v, OP_Goto, 0, end1);
+ 	  break;
+ 	}
      case SRT_Mem: {
        assert( nColumn==1 );
        sqliteVdbeAddOp(v, OP_MemStore, iParm, 1);
***************
*** 681,687 ****
          zType = pTab->aCol[iCol].zType;
        }
      }else{
!       if( sqliteExprType(p)==SQLITE_SO_TEXT ){
          zType = "TEXT";
        }else{
          zType = "NUMERIC";
--- 697,703 ----
          zType = pTab->aCol[iCol].zType;
        }
      }else{
!       if( sqliteExprType(p)==SQLITE_SO_TEXT ){
          zType = "TEXT";
        }else{
          zType = "NUMERIC";
***************
*** 973,979 ****
            }
            if( zTName && (zTabName==0 || zTabName[0]==0 || 
                   sqliteStrICmp(zTName, zTabName)!=0) ){
!             continue;
            }
            tableSeen = 1;
            for(j=0; j<pTab->nCol; j++){
--- 989,995 ----
            }
            if( zTName && (zTabName==0 || zTabName[0]==0 || 
                   sqliteStrICmp(zTName, zTabName)!=0) ){
!             continue;
            }
            tableSeen = 1;
            for(j=0; j<pTab->nCol; j++){
***************
*** 1999,2005 ****
  **     \                                                      /
  **      \____________________ outer query ___________________/
  **
! ** This routine is called for the outer query first.   For that call,
  ** pParent will be NULL.  During the processing of the outer query, this 
  ** routine is called recursively to handle the subquery.  For the recursive
  ** call, pParent will point to the outer query.  Because the subquery is
--- 2015,2021 ----
  **     \                                                      /
  **      \____________________ outer query ___________________/
  **
! ** This routine is called for the outer query first.   For that call,
  ** pParent will be NULL.  During the processing of the outer query, this 
  ** routine is called recursively to handle the subquery.  For the recursive
  ** call, pParent will point to the outer query.  Because the subquery is
diff -c ../sqlite-2.8.17/src/shell.c src/shell.c
*** ../sqlite-2.8.17/src/shell.c	2005-04-23 18:43:22.000000000 -0400
--- src/shell.c	2013-06-01 13:20:03.000000000 -0400
***************
*** 991,1003 ****
    return 1;
  }
  
  /*
  ** Return TRUE if the line typed in is an SQL command terminator other
  ** than a semi-colon.  The SQL Server style "go" command is understood
  ** as is the Oracle "/".
  */
  static int _is_command_terminator(const char *zLine){
-   extern int sqliteStrNICmp(const char*,const char*,int);
    while( isspace(*zLine) ){ zLine++; };
    if( zLine[0]=='/' && _all_whitespace(&zLine[1]) ) return 1;  /* Oracle */
    if( sqliteStrNICmp(zLine,"go",2)==0 && _all_whitespace(&zLine[2]) ){
--- 991,1004 ----
    return 1;
  }
  
+ extern int sqliteStrNICmp(const char*,const char*,int);
+ 
  /*
  ** Return TRUE if the line typed in is an SQL command terminator other
  ** than a semi-colon.  The SQL Server style "go" command is understood
  ** as is the Oracle "/".
  */
  static int _is_command_terminator(const char *zLine){
    while( isspace(*zLine) ){ zLine++; };
    if( zLine[0]=='/' && _all_whitespace(&zLine[1]) ) return 1;  /* Oracle */
    if( sqliteStrNICmp(zLine,"go",2)==0 && _all_whitespace(&zLine[2]) ){
***************
*** 1062,1068 ****
        if( rc || zErrMsg ){
          if( in!=0 && !p->echoOn ) printf("%s\n",zSql);
          if( zErrMsg!=0 ){
!           printf("SQL error: %s\n", zErrMsg);
            sqlite_freemem(zErrMsg);
            zErrMsg = 0;
          }else{
--- 1063,1069 ----
        if( rc || zErrMsg ){
          if( in!=0 && !p->echoOn ) printf("%s\n",zSql);
          if( zErrMsg!=0 ){
!           printf("SQL %s: %s\n", rc?"error":"warning", zErrMsg);
            sqlite_freemem(zErrMsg);
            zErrMsg = 0;
          }else{
***************
*** 1204,1209 ****
--- 1205,1212 ----
    strcpy(continuePrompt,"   ...> ");
  }
  
+ //#include <crtdbg.h>
+ 
  int main(int argc, char **argv){
    char *zErrMsg = 0;
    struct callback_data data;
***************
*** 1216,1221 ****
--- 1219,1234 ----
    argc = ccommand(&argv);
  #endif
  
+ /*
+ 	if(1) {
+ 		int tmpFlag = _CrtSetDbgFlag( _CRTDBG_REPORT_FLAG );
+     tmpFlag &= 0x0000ffff;
+ //		tmpFlag |= _CRTDBG_CHECK_ALWAYS_DF | _CRTDBG_ALLOC_MEM_DF;
+ 		_CrtSetDbgFlag( tmpFlag );
+ 	}
+ */
+ 
+ 
    Argv0 = argv[0];
    main_init(&data);
  
Only in src/: sqlite.h
diff -c ../sqlite-2.8.17/src/sqlite.h.in src/sqlite.h.in
*** ../sqlite-2.8.17/src/sqlite.h.in	2005-04-23 18:43:22.000000000 -0400
--- src/sqlite.h.in	2013-06-01 13:15:13.000000000 -0400
***************
*** 1,886 ****
! /*
! ** 2001 September 15
! **
! ** The author disclaims copyright to this source code.  In place of
! ** a legal notice, here is a blessing:
! **
! **    May you do good and not evil.
! **    May you find forgiveness for yourself and forgive others.
! **    May you share freely, never taking more than you give.
! **
! *************************************************************************
! ** This header file defines the interface that the SQLite library
! ** presents to client programs.
! **
! ** @(#) $Id: sqlite.h.in,v 1.60.2.1 2004/10/06 15:52:36 drh Exp $
! */
! #ifndef _SQLITE_H_
! #define _SQLITE_H_
! #include <stdarg.h>     /* Needed for the definition of va_list */
! 
! /*
! ** Make sure we can call this stuff from C++.
! */
! #ifdef __cplusplus
! extern "C" {
! #endif
! 
! /*
! ** The version of the SQLite library.
! */
! #ifdef SQLITE_VERSION
! # undef SQLITE_VERSION
! #else
! # define SQLITE_VERSION         "--VERS--"
! #endif
! 
! /*
! ** The version string is also compiled into the library so that a program
! ** can check to make sure that the lib*.a file and the *.h file are from
! ** the same version.
! */
! extern const char sqlite_version[];
! 
! /*
! ** The SQLITE_UTF8 macro is defined if the library expects to see
! ** UTF-8 encoded data.  The SQLITE_ISO8859 macro is defined if the
! ** iso8859 encoded should be used.
! */
! #define SQLITE_--ENCODING-- 1
! 
! /*
! ** The following constant holds one of two strings, "UTF-8" or "iso8859",
! ** depending on which character encoding the SQLite library expects to
! ** see.  The character encoding makes a difference for the LIKE and GLOB
! ** operators and for the LENGTH() and SUBSTR() functions.
! */
! extern const char sqlite_encoding[];
! 
! /*
! ** Each open sqlite database is represented by an instance of the
! ** following opaque structure.
! */
! typedef struct sqlite sqlite;
! 
! /*
! ** A function to open a new sqlite database.  
! **
! ** If the database does not exist and mode indicates write
! ** permission, then a new database is created.  If the database
! ** does not exist and mode does not indicate write permission,
! ** then the open fails, an error message generated (if errmsg!=0)
! ** and the function returns 0.
! ** 
! ** If mode does not indicates user write permission, then the 
! ** database is opened read-only.
! **
! ** The Truth:  As currently implemented, all databases are opened
! ** for writing all the time.  Maybe someday we will provide the
! ** ability to open a database readonly.  The mode parameters is
! ** provided in anticipation of that enhancement.
! */
! sqlite *sqlite_open(const char *filename, int mode, char **errmsg);
! 
! /*
! ** A function to close the database.
! **
! ** Call this function with a pointer to a structure that was previously
! ** returned from sqlite_open() and the corresponding database will by closed.
! */
! void sqlite_close(sqlite *);
! 
! /*
! ** The type for a callback function.
! */
! typedef int (*sqlite_callback)(void*,int,char**, char**);
! 
! /*
! ** A function to executes one or more statements of SQL.
! **
! ** If one or more of the SQL statements are queries, then
! ** the callback function specified by the 3rd parameter is
! ** invoked once for each row of the query result.  This callback
! ** should normally return 0.  If the callback returns a non-zero
! ** value then the query is aborted, all subsequent SQL statements
! ** are skipped and the sqlite_exec() function returns the SQLITE_ABORT.
! **
! ** The 4th parameter is an arbitrary pointer that is passed
! ** to the callback function as its first parameter.
! **
! ** The 2nd parameter to the callback function is the number of
! ** columns in the query result.  The 3rd parameter to the callback
! ** is an array of strings holding the values for each column.
! ** The 4th parameter to the callback is an array of strings holding
! ** the names of each column.
! **
! ** The callback function may be NULL, even for queries.  A NULL
! ** callback is not an error.  It just means that no callback
! ** will be invoked.
! **
! ** If an error occurs while parsing or evaluating the SQL (but
! ** not while executing the callback) then an appropriate error
! ** message is written into memory obtained from malloc() and
! ** *errmsg is made to point to that message.  The calling function
! ** is responsible for freeing the memory that holds the error
! ** message.   Use sqlite_freemem() for this.  If errmsg==NULL,
! ** then no error message is ever written.
! **
! ** The return value is is SQLITE_OK if there are no errors and
! ** some other return code if there is an error.  The particular
! ** return value depends on the type of error. 
! **
! ** If the query could not be executed because a database file is
! ** locked or busy, then this function returns SQLITE_BUSY.  (This
! ** behavior can be modified somewhat using the sqlite_busy_handler()
! ** and sqlite_busy_timeout() functions below.)
! */
! int sqlite_exec(
!   sqlite*,                      /* An open database */
!   const char *sql,              /* SQL to be executed */
!   sqlite_callback,              /* Callback function */
!   void *,                       /* 1st argument to callback function */
!   char **errmsg                 /* Error msg written here */
! );
! 
! /*
! ** Return values for sqlite_exec() and sqlite_step()
! */
! #define SQLITE_OK           0   /* Successful result */
! #define SQLITE_ERROR        1   /* SQL error or missing database */
! #define SQLITE_INTERNAL     2   /* An internal logic error in SQLite */
! #define SQLITE_PERM         3   /* Access permission denied */
! #define SQLITE_ABORT        4   /* Callback routine requested an abort */
! #define SQLITE_BUSY         5   /* The database file is locked */
! #define SQLITE_LOCKED       6   /* A table in the database is locked */
! #define SQLITE_NOMEM        7   /* A malloc() failed */
! #define SQLITE_READONLY     8   /* Attempt to write a readonly database */
! #define SQLITE_INTERRUPT    9   /* Operation terminated by sqlite_interrupt() */
! #define SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */
! #define SQLITE_CORRUPT     11   /* The database disk image is malformed */
! #define SQLITE_NOTFOUND    12   /* (Internal Only) Table or record not found */
! #define SQLITE_FULL        13   /* Insertion failed because database is full */
! #define SQLITE_CANTOPEN    14   /* Unable to open the database file */
! #define SQLITE_PROTOCOL    15   /* Database lock protocol error */
! #define SQLITE_EMPTY       16   /* (Internal Only) Database table is empty */
! #define SQLITE_SCHEMA      17   /* The database schema changed */
! #define SQLITE_TOOBIG      18   /* Too much data for one row of a table */
! #define SQLITE_CONSTRAINT  19   /* Abort due to contraint violation */
! #define SQLITE_MISMATCH    20   /* Data type mismatch */
! #define SQLITE_MISUSE      21   /* Library used incorrectly */
! #define SQLITE_NOLFS       22   /* Uses OS features not supported on host */
! #define SQLITE_AUTH        23   /* Authorization denied */
! #define SQLITE_FORMAT      24   /* Auxiliary database format error */
! #define SQLITE_RANGE       25   /* 2nd parameter to sqlite_bind out of range */
! #define SQLITE_NOTADB      26   /* File opened that is not a database file */
! #define SQLITE_ROW         100  /* sqlite_step() has another row ready */
! #define SQLITE_DONE        101  /* sqlite_step() has finished executing */
! 
! /*
! ** Each entry in an SQLite table has a unique integer key.  (The key is
! ** the value of the INTEGER PRIMARY KEY column if there is such a column,
! ** otherwise the key is generated at random.  The unique key is always
! ** available as the ROWID, OID, or _ROWID_ column.)  The following routine
! ** returns the integer key of the most recent insert in the database.
! **
! ** This function is similar to the mysql_insert_id() function from MySQL.
! */
! int sqlite_last_insert_rowid(sqlite*);
! 
! /*
! ** This function returns the number of database rows that were changed
! ** (or inserted or deleted) by the most recent called sqlite_exec().
! **
! ** All changes are counted, even if they were later undone by a
! ** ROLLBACK or ABORT.  Except, changes associated with creating and
! ** dropping tables are not counted.
! **
! ** If a callback invokes sqlite_exec() recursively, then the changes
! ** in the inner, recursive call are counted together with the changes
! ** in the outer call.
! **
! ** SQLite implements the command "DELETE FROM table" without a WHERE clause
! ** by dropping and recreating the table.  (This is much faster than going
! ** through and deleting individual elements form the table.)  Because of
! ** this optimization, the change count for "DELETE FROM table" will be
! ** zero regardless of the number of elements that were originally in the
! ** table. To get an accurate count of the number of rows deleted, use
! ** "DELETE FROM table WHERE 1" instead.
! */
! int sqlite_changes(sqlite*);
! 
! /*
! ** This function returns the number of database rows that were changed
! ** by the last INSERT, UPDATE, or DELETE statment executed by sqlite_exec(),
! ** or by the last VM to run to completion. The change count is not updated
! ** by SQL statements other than INSERT, UPDATE or DELETE.
! **
! ** Changes are counted, even if they are later undone by a ROLLBACK or
! ** ABORT. Changes associated with trigger programs that execute as a
! ** result of the INSERT, UPDATE, or DELETE statement are not counted.
! **
! ** If a callback invokes sqlite_exec() recursively, then the changes
! ** in the inner, recursive call are counted together with the changes
! ** in the outer call.
! **
! ** SQLite implements the command "DELETE FROM table" without a WHERE clause
! ** by dropping and recreating the table.  (This is much faster than going
! ** through and deleting individual elements form the table.)  Because of
! ** this optimization, the change count for "DELETE FROM table" will be
! ** zero regardless of the number of elements that were originally in the
! ** table. To get an accurate count of the number of rows deleted, use
! ** "DELETE FROM table WHERE 1" instead.
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! int sqlite_last_statement_changes(sqlite*);
! 
! /* If the parameter to this routine is one of the return value constants
! ** defined above, then this routine returns a constant text string which
! ** descripts (in English) the meaning of the return value.
! */
! const char *sqlite_error_string(int);
! #define sqliteErrStr sqlite_error_string  /* Legacy. Do not use in new code. */
! 
! /* This function causes any pending database operation to abort and
! ** return at its earliest opportunity.  This routine is typically
! ** called in response to a user action such as pressing "Cancel"
! ** or Ctrl-C where the user wants a long query operation to halt
! ** immediately.
! */
! void sqlite_interrupt(sqlite*);
! 
! 
! /* This function returns true if the given input string comprises
! ** one or more complete SQL statements.
! **
! ** The algorithm is simple.  If the last token other than spaces
! ** and comments is a semicolon, then return true.  otherwise return
! ** false.
! */
! int sqlite_complete(const char *sql);
! 
! /*
! ** This routine identifies a callback function that is invoked
! ** whenever an attempt is made to open a database table that is
! ** currently locked by another process or thread.  If the busy callback
! ** is NULL, then sqlite_exec() returns SQLITE_BUSY immediately if
! ** it finds a locked table.  If the busy callback is not NULL, then
! ** sqlite_exec() invokes the callback with three arguments.  The
! ** second argument is the name of the locked table and the third
! ** argument is the number of times the table has been busy.  If the
! ** busy callback returns 0, then sqlite_exec() immediately returns
! ** SQLITE_BUSY.  If the callback returns non-zero, then sqlite_exec()
! ** tries to open the table again and the cycle repeats.
! **
! ** The default busy callback is NULL.
! **
! ** Sqlite is re-entrant, so the busy handler may start a new query. 
! ** (It is not clear why anyone would every want to do this, but it
! ** is allowed, in theory.)  But the busy handler may not close the
! ** database.  Closing the database from a busy handler will delete 
! ** data structures out from under the executing query and will 
! ** probably result in a coredump.
! */
! void sqlite_busy_handler(sqlite*, int(*)(void*,const char*,int), void*);
! 
! /*
! ** This routine sets a busy handler that sleeps for a while when a
! ** table is locked.  The handler will sleep multiple times until 
! ** at least "ms" milleseconds of sleeping have been done.  After
! ** "ms" milleseconds of sleeping, the handler returns 0 which
! ** causes sqlite_exec() to return SQLITE_BUSY.
! **
! ** Calling this routine with an argument less than or equal to zero
! ** turns off all busy handlers.
! */
! void sqlite_busy_timeout(sqlite*, int ms);
! 
! /*
! ** This next routine is really just a wrapper around sqlite_exec().
! ** Instead of invoking a user-supplied callback for each row of the
! ** result, this routine remembers each row of the result in memory
! ** obtained from malloc(), then returns all of the result after the
! ** query has finished. 
! **
! ** As an example, suppose the query result where this table:
! **
! **        Name        | Age
! **        -----------------------
! **        Alice       | 43
! **        Bob         | 28
! **        Cindy       | 21
! **
! ** If the 3rd argument were &azResult then after the function returns
! ** azResult will contain the following data:
! **
! **        azResult[0] = "Name";
! **        azResult[1] = "Age";
! **        azResult[2] = "Alice";
! **        azResult[3] = "43";
! **        azResult[4] = "Bob";
! **        azResult[5] = "28";
! **        azResult[6] = "Cindy";
! **        azResult[7] = "21";
! **
! ** Notice that there is an extra row of data containing the column
! ** headers.  But the *nrow return value is still 3.  *ncolumn is
! ** set to 2.  In general, the number of values inserted into azResult
! ** will be ((*nrow) + 1)*(*ncolumn).
! **
! ** After the calling function has finished using the result, it should 
! ** pass the result data pointer to sqlite_free_table() in order to 
! ** release the memory that was malloc-ed.  Because of the way the 
! ** malloc() happens, the calling function must not try to call 
! ** malloc() directly.  Only sqlite_free_table() is able to release 
! ** the memory properly and safely.
! **
! ** The return value of this routine is the same as from sqlite_exec().
! */
! int sqlite_get_table(
!   sqlite*,               /* An open database */
!   const char *sql,       /* SQL to be executed */
!   char ***resultp,       /* Result written to a char *[]  that this points to */
!   int *nrow,             /* Number of result rows written here */
!   int *ncolumn,          /* Number of result columns written here */
!   char **errmsg          /* Error msg written here */
! );
! 
! /*
! ** Call this routine to free the memory that sqlite_get_table() allocated.
! */
! void sqlite_free_table(char **result);
! 
! /*
! ** The following routines are wrappers around sqlite_exec() and
! ** sqlite_get_table().  The only difference between the routines that
! ** follow and the originals is that the second argument to the 
! ** routines that follow is really a printf()-style format
! ** string describing the SQL to be executed.  Arguments to the format
! ** string appear at the end of the argument list.
! **
! ** All of the usual printf formatting options apply.  In addition, there
! ** is a "%q" option.  %q works like %s in that it substitutes a null-terminated
! ** string from the argument list.  But %q also doubles every '\'' character.
! ** %q is designed for use inside a string literal.  By doubling each '\''
! ** character it escapes that character and allows it to be inserted into
! ** the string.
! **
! ** For example, so some string variable contains text as follows:
! **
! **      char *zText = "It's a happy day!";
! **
! ** We can use this text in an SQL statement as follows:
! **
! **      sqlite_exec_printf(db, "INSERT INTO table VALUES('%q')",
! **          callback1, 0, 0, zText);
! **
! ** Because the %q format string is used, the '\'' character in zText
! ** is escaped and the SQL generated is as follows:
! **
! **      INSERT INTO table1 VALUES('It''s a happy day!')
! **
! ** This is correct.  Had we used %s instead of %q, the generated SQL
! ** would have looked like this:
! **
! **      INSERT INTO table1 VALUES('It's a happy day!');
! **
! ** This second example is an SQL syntax error.  As a general rule you
! ** should always use %q instead of %s when inserting text into a string 
! ** literal.
! */
! int sqlite_exec_printf(
!   sqlite*,                      /* An open database */
!   const char *sqlFormat,        /* printf-style format string for the SQL */
!   sqlite_callback,              /* Callback function */
!   void *,                       /* 1st argument to callback function */
!   char **errmsg,                /* Error msg written here */
!   ...                           /* Arguments to the format string. */
! );
! int sqlite_exec_vprintf(
!   sqlite*,                      /* An open database */
!   const char *sqlFormat,        /* printf-style format string for the SQL */
!   sqlite_callback,              /* Callback function */
!   void *,                       /* 1st argument to callback function */
!   char **errmsg,                /* Error msg written here */
!   va_list ap                    /* Arguments to the format string. */
! );
! int sqlite_get_table_printf(
!   sqlite*,               /* An open database */
!   const char *sqlFormat, /* printf-style format string for the SQL */
!   char ***resultp,       /* Result written to a char *[]  that this points to */
!   int *nrow,             /* Number of result rows written here */
!   int *ncolumn,          /* Number of result columns written here */
!   char **errmsg,         /* Error msg written here */
!   ...                    /* Arguments to the format string */
! );
! int sqlite_get_table_vprintf(
!   sqlite*,               /* An open database */
!   const char *sqlFormat, /* printf-style format string for the SQL */
!   char ***resultp,       /* Result written to a char *[]  that this points to */
!   int *nrow,             /* Number of result rows written here */
!   int *ncolumn,          /* Number of result columns written here */
!   char **errmsg,         /* Error msg written here */
!   va_list ap             /* Arguments to the format string */
! );
! char *sqlite_mprintf(const char*,...);
! char *sqlite_vmprintf(const char*, va_list);
! 
! /*
! ** Windows systems should call this routine to free memory that
! ** is returned in the in the errmsg parameter of sqlite_open() when
! ** SQLite is a DLL.  For some reason, it does not work to call free()
! ** directly.
! */
! void sqlite_freemem(void *p);
! 
! /*
! ** Windows systems need functions to call to return the sqlite_version
! ** and sqlite_encoding strings.
! */
! const char *sqlite_libversion(void);
! const char *sqlite_libencoding(void);
! 
! /*
! ** A pointer to the following structure is used to communicate with
! ** the implementations of user-defined functions.
! */
! typedef struct sqlite_func sqlite_func;
! 
! /*
! ** Use the following routines to create new user-defined functions.  See
! ** the documentation for details.
! */
! int sqlite_create_function(
!   sqlite*,                  /* Database where the new function is registered */
!   const char *zName,        /* Name of the new function */
!   int nArg,                 /* Number of arguments.  -1 means any number */
!   void (*xFunc)(sqlite_func*,int,const char**),  /* C code to implement */
!   void *pUserData           /* Available via the sqlite_user_data() call */
! );
! int sqlite_create_aggregate(
!   sqlite*,                  /* Database where the new function is registered */
!   const char *zName,        /* Name of the function */
!   int nArg,                 /* Number of arguments */
!   void (*xStep)(sqlite_func*,int,const char**), /* Called for each row */
!   void (*xFinalize)(sqlite_func*),       /* Called once to get final result */
!   void *pUserData           /* Available via the sqlite_user_data() call */
! );
! 
! /*
! ** Use the following routine to define the datatype returned by a
! ** user-defined function.  The second argument can be one of the
! ** constants SQLITE_NUMERIC, SQLITE_TEXT, or SQLITE_ARGS or it
! ** can be an integer greater than or equal to zero.  When the datatype
! ** parameter is non-negative, the type of the result will be the
! ** same as the datatype-th argument.  If datatype==SQLITE_NUMERIC
! ** then the result is always numeric.  If datatype==SQLITE_TEXT then
! ** the result is always text.  If datatype==SQLITE_ARGS then the result
! ** is numeric if any argument is numeric and is text otherwise.
! */
! int sqlite_function_type(
!   sqlite *db,               /* The database there the function is registered */
!   const char *zName,        /* Name of the function */
!   int datatype              /* The datatype for this function */
! );
! #define SQLITE_NUMERIC     (-1)
! /* #define SQLITE_TEXT     (-2)  // See below */
! #define SQLITE_ARGS        (-3)
! 
! /*
! ** SQLite version 3 defines SQLITE_TEXT differently.  To allow both
! ** version 2 and version 3 to be included, undefine them both if a
! ** conflict is seen.  Define SQLITE2_TEXT to be the version 2 value.
! */
! #ifdef SQLITE_TEXT
! # undef SQLITE_TEXT
! #else
! # define SQLITE_TEXT     (-2)
! #endif
! #define SQLITE2_TEXT     (-2)
! 
! 
! 
! /*
! ** The user function implementations call one of the following four routines
! ** in order to return their results.  The first parameter to each of these
! ** routines is a copy of the first argument to xFunc() or xFinialize().
! ** The second parameter to these routines is the result to be returned.
! ** A NULL can be passed as the second parameter to sqlite_set_result_string()
! ** in order to return a NULL result.
! **
! ** The 3rd argument to _string and _error is the number of characters to
! ** take from the string.  If this argument is negative, then all characters
! ** up to and including the first '\000' are used.
! **
! ** The sqlite_set_result_string() function allocates a buffer to hold the
! ** result and returns a pointer to this buffer.  The calling routine
! ** (that is, the implmentation of a user function) can alter the content
! ** of this buffer if desired.
! */
! char *sqlite_set_result_string(sqlite_func*,const char*,int);
! void sqlite_set_result_int(sqlite_func*,int);
! void sqlite_set_result_double(sqlite_func*,double);
! void sqlite_set_result_error(sqlite_func*,const char*,int);
! 
! /*
! ** The pUserData parameter to the sqlite_create_function() and
! ** sqlite_create_aggregate() routines used to register user functions
! ** is available to the implementation of the function using this
! ** call.
! */
! void *sqlite_user_data(sqlite_func*);
! 
! /*
! ** Aggregate functions use the following routine to allocate
! ** a structure for storing their state.  The first time this routine
! ** is called for a particular aggregate, a new structure of size nBytes
! ** is allocated, zeroed, and returned.  On subsequent calls (for the
! ** same aggregate instance) the same buffer is returned.  The implementation
! ** of the aggregate can use the returned buffer to accumulate data.
! **
! ** The buffer allocated is freed automatically be SQLite.
! */
! void *sqlite_aggregate_context(sqlite_func*, int nBytes);
! 
! /*
! ** The next routine returns the number of calls to xStep for a particular
! ** aggregate function instance.  The current call to xStep counts so this
! ** routine always returns at least 1.
! */
! int sqlite_aggregate_count(sqlite_func*);
! 
! /*
! ** This routine registers a callback with the SQLite library.  The
! ** callback is invoked (at compile-time, not at run-time) for each
! ** attempt to access a column of a table in the database.  The callback
! ** returns SQLITE_OK if access is allowed, SQLITE_DENY if the entire
! ** SQL statement should be aborted with an error and SQLITE_IGNORE
! ** if the column should be treated as a NULL value.
! */
! int sqlite_set_authorizer(
!   sqlite*,
!   int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
!   void *pUserData
! );
! 
! /*
! ** The second parameter to the access authorization function above will
! ** be one of the values below.  These values signify what kind of operation
! ** is to be authorized.  The 3rd and 4th parameters to the authorization
! ** function will be parameters or NULL depending on which of the following
! ** codes is used as the second parameter.  The 5th parameter is the name
! ** of the database ("main", "temp", etc.) if applicable.  The 6th parameter
! ** is the name of the inner-most trigger or view that is responsible for
! ** the access attempt or NULL if this access attempt is directly from 
! ** input SQL code.
! **
! **                                          Arg-3           Arg-4
! */
! #define SQLITE_COPY                  0   /* Table Name      File Name       */
! #define SQLITE_CREATE_INDEX          1   /* Index Name      Table Name      */
! #define SQLITE_CREATE_TABLE          2   /* Table Name      NULL            */
! #define SQLITE_CREATE_TEMP_INDEX     3   /* Index Name      Table Name      */
! #define SQLITE_CREATE_TEMP_TABLE     4   /* Table Name      NULL            */
! #define SQLITE_CREATE_TEMP_TRIGGER   5   /* Trigger Name    Table Name      */
! #define SQLITE_CREATE_TEMP_VIEW      6   /* View Name       NULL            */
! #define SQLITE_CREATE_TRIGGER        7   /* Trigger Name    Table Name      */
! #define SQLITE_CREATE_VIEW           8   /* View Name       NULL            */
! #define SQLITE_DELETE                9   /* Table Name      NULL            */
! #define SQLITE_DROP_INDEX           10   /* Index Name      Table Name      */
! #define SQLITE_DROP_TABLE           11   /* Table Name      NULL            */
! #define SQLITE_DROP_TEMP_INDEX      12   /* Index Name      Table Name      */
! #define SQLITE_DROP_TEMP_TABLE      13   /* Table Name      NULL            */
! #define SQLITE_DROP_TEMP_TRIGGER    14   /* Trigger Name    Table Name      */
! #define SQLITE_DROP_TEMP_VIEW       15   /* View Name       NULL            */
! #define SQLITE_DROP_TRIGGER         16   /* Trigger Name    Table Name      */
! #define SQLITE_DROP_VIEW            17   /* View Name       NULL            */
! #define SQLITE_INSERT               18   /* Table Name      NULL            */
! #define SQLITE_PRAGMA               19   /* Pragma Name     1st arg or NULL */
! #define SQLITE_READ                 20   /* Table Name      Column Name     */
! #define SQLITE_SELECT               21   /* NULL            NULL            */
! #define SQLITE_TRANSACTION          22   /* NULL            NULL            */
! #define SQLITE_UPDATE               23   /* Table Name      Column Name     */
! #define SQLITE_ATTACH               24   /* Filename        NULL            */
! #define SQLITE_DETACH               25   /* Database Name   NULL            */
! 
! 
! /*
! ** The return value of the authorization function should be one of the
! ** following constants:
! */
! /* #define SQLITE_OK  0   // Allow access (This is actually defined above) */
! #define SQLITE_DENY   1   /* Abort the SQL statement with an error */
! #define SQLITE_IGNORE 2   /* Don't allow access, but don't generate an error */
! 
! /*
! ** Register a function that is called at every invocation of sqlite_exec()
! ** or sqlite_compile().  This function can be used (for example) to generate
! ** a log file of all SQL executed against a database.
! */
! void *sqlite_trace(sqlite*, void(*xTrace)(void*,const char*), void*);
! 
! /*** The Callback-Free API
! ** 
! ** The following routines implement a new way to access SQLite that does not
! ** involve the use of callbacks.
! **
! ** An sqlite_vm is an opaque object that represents a single SQL statement
! ** that is ready to be executed.
! */
! typedef struct sqlite_vm sqlite_vm;
! 
! /*
! ** To execute an SQLite query without the use of callbacks, you first have
! ** to compile the SQL using this routine.  The 1st parameter "db" is a pointer
! ** to an sqlite object obtained from sqlite_open().  The 2nd parameter
! ** "zSql" is the text of the SQL to be compiled.   The remaining parameters
! ** are all outputs.
! **
! ** *pzTail is made to point to the first character past the end of the first
! ** SQL statement in zSql.  This routine only compiles the first statement
! ** in zSql, so *pzTail is left pointing to what remains uncompiled.
! **
! ** *ppVm is left pointing to a "virtual machine" that can be used to execute
! ** the compiled statement.  Or if there is an error, *ppVm may be set to NULL.
! ** If the input text contained no SQL (if the input is and empty string or
! ** a comment) then *ppVm is set to NULL.
! **
! ** If any errors are detected during compilation, an error message is written
! ** into space obtained from malloc() and *pzErrMsg is made to point to that
! ** error message.  The calling routine is responsible for freeing the text
! ** of this message when it has finished with it.  Use sqlite_freemem() to
! ** free the message.  pzErrMsg may be NULL in which case no error message
! ** will be generated.
! **
! ** On success, SQLITE_OK is returned.  Otherwise and error code is returned.
! */
! int sqlite_compile(
!   sqlite *db,                   /* The open database */
!   const char *zSql,             /* SQL statement to be compiled */
!   const char **pzTail,          /* OUT: uncompiled tail of zSql */
!   sqlite_vm **ppVm,             /* OUT: the virtual machine to execute zSql */
!   char **pzErrmsg               /* OUT: Error message. */
! );
! 
! /*
! ** After an SQL statement has been compiled, it is handed to this routine
! ** to be executed.  This routine executes the statement as far as it can
! ** go then returns.  The return value will be one of SQLITE_DONE,
! ** SQLITE_ERROR, SQLITE_BUSY, SQLITE_ROW, or SQLITE_MISUSE.
! **
! ** SQLITE_DONE means that the execute of the SQL statement is complete
! ** an no errors have occurred.  sqlite_step() should not be called again
! ** for the same virtual machine.  *pN is set to the number of columns in
! ** the result set and *pazColName is set to an array of strings that
! ** describe the column names and datatypes.  The name of the i-th column
! ** is (*pazColName)[i] and the datatype of the i-th column is
! ** (*pazColName)[i+*pN].  *pazValue is set to NULL.
! **
! ** SQLITE_ERROR means that the virtual machine encountered a run-time
! ** error.  sqlite_step() should not be called again for the same
! ** virtual machine.  *pN is set to 0 and *pazColName and *pazValue are set
! ** to NULL.  Use sqlite_finalize() to obtain the specific error code
! ** and the error message text for the error.
! **
! ** SQLITE_BUSY means that an attempt to open the database failed because
! ** another thread or process is holding a lock.  The calling routine
! ** can try again to open the database by calling sqlite_step() again.
! ** The return code will only be SQLITE_BUSY if no busy handler is registered
! ** using the sqlite_busy_handler() or sqlite_busy_timeout() routines.  If
! ** a busy handler callback has been registered but returns 0, then this
! ** routine will return SQLITE_ERROR and sqltie_finalize() will return
! ** SQLITE_BUSY when it is called.
! **
! ** SQLITE_ROW means that a single row of the result is now available.
! ** The data is contained in *pazValue.  The value of the i-th column is
! ** (*azValue)[i].  *pN and *pazColName are set as described in SQLITE_DONE.
! ** Invoke sqlite_step() again to advance to the next row.
! **
! ** SQLITE_MISUSE is returned if sqlite_step() is called incorrectly.
! ** For example, if you call sqlite_step() after the virtual machine
! ** has halted (after a prior call to sqlite_step() has returned SQLITE_DONE)
! ** or if you call sqlite_step() with an incorrectly initialized virtual
! ** machine or a virtual machine that has been deleted or that is associated
! ** with an sqlite structure that has been closed.
! */
! int sqlite_step(
!   sqlite_vm *pVm,              /* The virtual machine to execute */
!   int *pN,                     /* OUT: Number of columns in result */
!   const char ***pazValue,      /* OUT: Column data */
!   const char ***pazColName     /* OUT: Column names and datatypes */
! );
! 
! /*
! ** This routine is called to delete a virtual machine after it has finished
! ** executing.  The return value is the result code.  SQLITE_OK is returned
! ** if the statement executed successfully and some other value is returned if
! ** there was any kind of error.  If an error occurred and pzErrMsg is not
! ** NULL, then an error message is written into memory obtained from malloc()
! ** and *pzErrMsg is made to point to that error message.  The calling routine
! ** should use sqlite_freemem() to delete this message when it has finished
! ** with it.
! **
! ** This routine can be called at any point during the execution of the
! ** virtual machine.  If the virtual machine has not completed execution
! ** when this routine is called, that is like encountering an error or
! ** an interrupt.  (See sqlite_interrupt().)  Incomplete updates may be
! ** rolled back and transactions cancelled,  depending on the circumstances,
! ** and the result code returned will be SQLITE_ABORT.
! */
! int sqlite_finalize(sqlite_vm*, char **pzErrMsg);
! 
! /*
! ** This routine deletes the virtual machine, writes any error message to
! ** *pzErrMsg and returns an SQLite return code in the same way as the
! ** sqlite_finalize() function.
! **
! ** Additionally, if ppVm is not NULL, *ppVm is left pointing to a new virtual
! ** machine loaded with the compiled version of the original query ready for
! ** execution.
! **
! ** If sqlite_reset() returns SQLITE_SCHEMA, then *ppVm is set to NULL.
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! int sqlite_reset(sqlite_vm*, char **pzErrMsg);
! 
! /*
! ** If the SQL that was handed to sqlite_compile contains variables that
! ** are represeted in the SQL text by a question mark ('?').  This routine
! ** is used to assign values to those variables.
! **
! ** The first parameter is a virtual machine obtained from sqlite_compile().
! ** The 2nd "idx" parameter determines which variable in the SQL statement
! ** to bind the value to.  The left most '?' is 1.  The 3rd parameter is
! ** the value to assign to that variable.  The 4th parameter is the number
! ** of bytes in the value, including the terminating \000 for strings.
! ** Finally, the 5th "copy" parameter is TRUE if SQLite should make its
! ** own private copy of this value, or false if the space that the 3rd
! ** parameter points to will be unchanging and can be used directly by
! ** SQLite.
! **
! ** Unbound variables are treated as having a value of NULL.  To explicitly
! ** set a variable to NULL, call this routine with the 3rd parameter as a
! ** NULL pointer.
! **
! ** If the 4th "len" parameter is -1, then strlen() is used to find the
! ** length.
! **
! ** This routine can only be called immediately after sqlite_compile()
! ** or sqlite_reset() and before any calls to sqlite_step().
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! int sqlite_bind(sqlite_vm*, int idx, const char *value, int len, int copy);
! 
! /*
! ** This routine configures a callback function - the progress callback - that
! ** is invoked periodically during long running calls to sqlite_exec(),
! ** sqlite_step() and sqlite_get_table(). An example use for this API is to keep
! ** a GUI updated during a large query.
! **
! ** The progress callback is invoked once for every N virtual machine opcodes,
! ** where N is the second argument to this function. The progress callback
! ** itself is identified by the third argument to this function. The fourth
! ** argument to this function is a void pointer passed to the progress callback
! ** function each time it is invoked.
! **
! ** If a call to sqlite_exec(), sqlite_step() or sqlite_get_table() results 
! ** in less than N opcodes being executed, then the progress callback is not
! ** invoked.
! ** 
! ** Calling this routine overwrites any previously installed progress callback.
! ** To remove the progress callback altogether, pass NULL as the third
! ** argument to this function.
! **
! ** If the progress callback returns a result other than 0, then the current 
! ** query is immediately terminated and any database changes rolled back. If the
! ** query was part of a larger transaction, then the transaction is not rolled
! ** back and remains active. The sqlite_exec() call returns SQLITE_ABORT. 
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! void sqlite_progress_handler(sqlite*, int, int(*)(void*), void*);
! 
! /*
! ** Register a callback function to be invoked whenever a new transaction
! ** is committed.  The pArg argument is passed through to the callback.
! ** callback.  If the callback function returns non-zero, then the commit
! ** is converted into a rollback.
! **
! ** If another function was previously registered, its pArg value is returned.
! ** Otherwise NULL is returned.
! **
! ** Registering a NULL function disables the callback.
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! void *sqlite_commit_hook(sqlite*, int(*)(void*), void*);
! 
! /*
! ** Open an encrypted SQLite database.  If pKey==0 or nKey==0, this routine
! ** is the same as sqlite_open().
! **
! ** The code to implement this API is not available in the public release
! ** of SQLite.
! */
! sqlite *sqlite_open_encrypted(
!   const char *zFilename,   /* Name of the encrypted database */
!   const void *pKey,        /* Pointer to the key */
!   int nKey,                /* Number of bytes in the key */
!   int *pErrcode,           /* Write error code here */
!   char **pzErrmsg          /* Write error message here */
! );
! 
! /*
! ** Change the key on an open database.  If the current database is not
! ** encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, the
! ** database is decrypted.
! **
! ** The code to implement this API is not available in the public release
! ** of SQLite.
! */
! int sqlite_rekey(
!   sqlite *db,                    /* Database to be rekeyed */
!   const void *pKey, int nKey     /* The new key */
! );
! 
! /*
! ** Encode a binary buffer "in" of size n bytes so that it contains
! ** no instances of characters '\'' or '\000'.  The output is 
! ** null-terminated and can be used as a string value in an INSERT
! ** or UPDATE statement.  Use sqlite_decode_binary() to convert the
! ** string back into its original binary.
! **
! ** The result is written into a preallocated output buffer "out".
! ** "out" must be able to hold at least 2 +(257*n)/254 bytes.
! ** In other words, the output will be expanded by as much as 3
! ** bytes for every 254 bytes of input plus 2 bytes of fixed overhead.
! ** (This is approximately 2 + 1.0118*n or about a 1.2% size increase.)
! **
! ** The return value is the number of characters in the encoded
! ** string, excluding the "\000" terminator.
! **
! ** If out==NULL then no output is generated but the routine still returns
! ** the number of characters that would have been generated if out had
! ** not been NULL.
! */
! int sqlite_encode_binary(const unsigned char *in, int n, unsigned char *out);
! 
! /*
! ** Decode the string "in" into binary data and write it into "out".
! ** This routine reverses the encoding created by sqlite_encode_binary().
! ** The output will always be a few bytes less than the input.  The number
! ** of bytes of output is returned.  If the input is not a well-formed
! ** encoding, -1 is returned.
! **
! ** The "in" and "out" parameters may point to the same buffer in order
! ** to decode a string in place.
! */
! int sqlite_decode_binary(const unsigned char *in, unsigned char *out);
! 
! #ifdef __cplusplus
! }  /* End of the 'extern "C"' block */
! #endif
! 
! #endif /* _SQLITE_H_ */
--- 1,886 ----
! /*
! ** 2001 September 15
! **
! ** The author disclaims copyright to this source code.  In place of
! ** a legal notice, here is a blessing:
! **
! **    May you do good and not evil.
! **    May you find forgiveness for yourself and forgive others.
! **    May you share freely, never taking more than you give.
! **
! *************************************************************************
! ** This header file defines the interface that the SQLite library
! ** presents to client programs.
! **
! ** @(#) $Id: sqlite.h.in,v 1.60.2.1 2004/10/06 15:52:36 drh Exp $
! */
! #ifndef _SQLITE_H_
! #define _SQLITE_H_
! #include <stdarg.h>     /* Needed for the definition of va_list */
! 
! /*
! ** Make sure we can call this stuff from C++.
! */
! #ifdef __cplusplus
! extern "C" {
! #endif
! 
! /*
! ** The version of the SQLite library.
! */
! #ifdef SQLITE_VERSION
! # undef SQLITE_VERSION
! #else
! # define SQLITE_VERSION         "--VERS--"
! #endif
! 
! /*
! ** The version string is also compiled into the library so that a program
! ** can check to make sure that the lib*.a file and the *.h file are from
! ** the same version.
! */
! extern const char sqlite_version[];
! 
! /*
! ** The SQLITE_UTF8 macro is defined if the library expects to see
! ** UTF-8 encoded data.  The SQLITE_ISO8859 macro is defined if the
! ** iso8859 encoded should be used.
! */
! #define SQLITE_--ENCODING-- 1
! 
! /*
! ** The following constant holds one of two strings, "UTF-8" or "iso8859",
! ** depending on which character encoding the SQLite library expects to
! ** see.  The character encoding makes a difference for the LIKE and GLOB
! ** operators and for the LENGTH() and SUBSTR() functions.
! */
! extern const char sqlite_encoding[];
! 
! /*
! ** Each open sqlite database is represented by an instance of the
! ** following opaque structure.
! */
! typedef struct sqlite sqlite;
! 
! /*
! ** A function to open a new sqlite database.  
! **
! ** If the database does not exist and mode indicates write
! ** permission, then a new database is created.  If the database
! ** does not exist and mode does not indicate write permission,
! ** then the open fails, an error message generated (if errmsg!=0)
! ** and the function returns 0.
! ** 
! ** If mode does not indicates user write permission, then the 
! ** database is opened read-only.
! **
! ** The Truth:  As currently implemented, all databases are opened
! ** for writing all the time.  Maybe someday we will provide the
! ** ability to open a database readonly.  The mode parameters is
! ** provided in anticipation of that enhancement.
! */
! sqlite *sqlite_open(const char *filename, int mode, char **errmsg);
! 
! /*
! ** A function to close the database.
! **
! ** Call this function with a pointer to a structure that was previously
! ** returned from sqlite_open() and the corresponding database will by closed.
! */
! void sqlite_close(sqlite *);
! 
! /*
! ** The type for a callback function.
! */
! typedef int (*sqlite_callback)(void*,int,char**, char**);
! 
! /*
! ** A function to executes one or more statements of SQL.
! **
! ** If one or more of the SQL statements are queries, then
! ** the callback function specified by the 3rd parameter is
! ** invoked once for each row of the query result.  This callback
! ** should normally return 0.  If the callback returns a non-zero
! ** value then the query is aborted, all subsequent SQL statements
! ** are skipped and the sqlite_exec() function returns the SQLITE_ABORT.
! **
! ** The 4th parameter is an arbitrary pointer that is passed
! ** to the callback function as its first parameter.
! **
! ** The 2nd parameter to the callback function is the number of
! ** columns in the query result.  The 3rd parameter to the callback
! ** is an array of strings holding the values for each column.
! ** The 4th parameter to the callback is an array of strings holding
! ** the names of each column.
! **
! ** The callback function may be NULL, even for queries.  A NULL
! ** callback is not an error.  It just means that no callback
! ** will be invoked.
! **
! ** If an error occurs while parsing or evaluating the SQL (but
! ** not while executing the callback) then an appropriate error
! ** message is written into memory obtained from malloc() and
! ** *errmsg is made to point to that message.  The calling function
! ** is responsible for freeing the memory that holds the error
! ** message.   Use sqlite_freemem() for this.  If errmsg==NULL,
! ** then no error message is ever written.
! **
! ** The return value is is SQLITE_OK if there are no errors and
! ** some other return code if there is an error.  The particular
! ** return value depends on the type of error. 
! **
! ** If the query could not be executed because a database file is
! ** locked or busy, then this function returns SQLITE_BUSY.  (This
! ** behavior can be modified somewhat using the sqlite_busy_handler()
! ** and sqlite_busy_timeout() functions below.)
! */
! int sqlite_exec(
!   sqlite*,                      /* An open database */
!   const char *sql,              /* SQL to be executed */
!   sqlite_callback,              /* Callback function */
!   void *,                       /* 1st argument to callback function */
!   char **errmsg                 /* Error msg written here */
! );
! 
! /*
! ** Return values for sqlite_exec() and sqlite_step()
! */
! #define SQLITE_OK           0   /* Successful result */
! #define SQLITE_ERROR        1   /* SQL error or missing database */
! #define SQLITE_INTERNAL     2   /* An internal logic error in SQLite */
! #define SQLITE_PERM         3   /* Access permission denied */
! #define SQLITE_ABORT        4   /* Callback routine requested an abort */
! #define SQLITE_BUSY         5   /* The database file is locked */
! #define SQLITE_LOCKED       6   /* A table in the database is locked */
! #define SQLITE_NOMEM        7   /* A malloc() failed */
! #define SQLITE_READONLY     8   /* Attempt to write a readonly database */
! #define SQLITE_INTERRUPT    9   /* Operation terminated by sqlite_interrupt() */
! #define SQLITE_IOERR       10   /* Some kind of disk I/O error occurred */
! #define SQLITE_CORRUPT     11   /* The database disk image is malformed */
! #define SQLITE_NOTFOUND    12   /* (Internal Only) Table or record not found */
! #define SQLITE_FULL        13   /* Insertion failed because database is full */
! #define SQLITE_CANTOPEN    14   /* Unable to open the database file */
! #define SQLITE_PROTOCOL    15   /* Database lock protocol error */
! #define SQLITE_EMPTY       16   /* (Internal Only) Database table is empty */
! #define SQLITE_SCHEMA      17   /* The database schema changed */
! #define SQLITE_TOOBIG      18   /* Too much data for one row of a table */
! #define SQLITE_CONSTRAINT  19   /* Abort due to contraint violation */
! #define SQLITE_MISMATCH    20   /* Data type mismatch */
! #define SQLITE_MISUSE      21   /* Library used incorrectly */
! #define SQLITE_NOLFS       22   /* Uses OS features not supported on host */
! #define SQLITE_AUTH        23   /* Authorization denied */
! #define SQLITE_FORMAT      24   /* Auxiliary database format error */
! #define SQLITE_RANGE       25   /* 2nd parameter to sqlite_bind out of range */
! #define SQLITE_NOTADB      26   /* File opened that is not a database file */
! #define SQLITE_ROW         100  /* sqlite_step() has another row ready */
! #define SQLITE_DONE        101  /* sqlite_step() has finished executing */
! 
! /*
! ** Each entry in an SQLite table has a unique integer key.  (The key is
! ** the value of the INTEGER PRIMARY KEY column if there is such a column,
! ** otherwise the key is generated at random.  The unique key is always
! ** available as the ROWID, OID, or _ROWID_ column.)  The following routine
! ** returns the integer key of the most recent insert in the database.
! **
! ** This function is similar to the mysql_insert_id() function from MySQL.
! */
! int sqlite_last_insert_rowid(sqlite*);
! 
! /*
! ** This function returns the number of database rows that were changed
! ** (or inserted or deleted) by the most recent called sqlite_exec().
! **
! ** All changes are counted, even if they were later undone by a
! ** ROLLBACK or ABORT.  Except, changes associated with creating and
! ** dropping tables are not counted.
! **
! ** If a callback invokes sqlite_exec() recursively, then the changes
! ** in the inner, recursive call are counted together with the changes
! ** in the outer call.
! **
! ** SQLite implements the command "DELETE FROM table" without a WHERE clause
! ** by dropping and recreating the table.  (This is much faster than going
! ** through and deleting individual elements form the table.)  Because of
! ** this optimization, the change count for "DELETE FROM table" will be
! ** zero regardless of the number of elements that were originally in the
! ** table. To get an accurate count of the number of rows deleted, use
! ** "DELETE FROM table WHERE 1" instead.
! */
! int sqlite_changes(sqlite*);
! 
! /*
! ** This function returns the number of database rows that were changed
! ** by the last INSERT, UPDATE, or DELETE statment executed by sqlite_exec(),
! ** or by the last VM to run to completion. The change count is not updated
! ** by SQL statements other than INSERT, UPDATE or DELETE.
! **
! ** Changes are counted, even if they are later undone by a ROLLBACK or
! ** ABORT. Changes associated with trigger programs that execute as a
! ** result of the INSERT, UPDATE, or DELETE statement are not counted.
! **
! ** If a callback invokes sqlite_exec() recursively, then the changes
! ** in the inner, recursive call are counted together with the changes
! ** in the outer call.
! **
! ** SQLite implements the command "DELETE FROM table" without a WHERE clause
! ** by dropping and recreating the table.  (This is much faster than going
! ** through and deleting individual elements form the table.)  Because of
! ** this optimization, the change count for "DELETE FROM table" will be
! ** zero regardless of the number of elements that were originally in the
! ** table. To get an accurate count of the number of rows deleted, use
! ** "DELETE FROM table WHERE 1" instead.
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! int sqlite_last_statement_changes(sqlite*);
! 
! /* If the parameter to this routine is one of the return value constants
! ** defined above, then this routine returns a constant text string which
! ** descripts (in English) the meaning of the return value.
! */
! const char *sqlite_error_string(int);
! #define sqliteErrStr sqlite_error_string  /* Legacy. Do not use in new code. */
! 
! /* This function causes any pending database operation to abort and
! ** return at its earliest opportunity.  This routine is typically
! ** called in response to a user action such as pressing "Cancel"
! ** or Ctrl-C where the user wants a long query operation to halt
! ** immediately.
! */
! void sqlite_interrupt(sqlite*);
! 
! 
! /* This function returns true if the given input string comprises
! ** one or more complete SQL statements.
! **
! ** The algorithm is simple.  If the last token other than spaces
! ** and comments is a semicolon, then return true.  otherwise return
! ** false.
! */
! int sqlite_complete(const char *sql);
! 
! /*
! ** This routine identifies a callback function that is invoked
! ** whenever an attempt is made to open a database table that is
! ** currently locked by another process or thread.  If the busy callback
! ** is NULL, then sqlite_exec() returns SQLITE_BUSY immediately if
! ** it finds a locked table.  If the busy callback is not NULL, then
! ** sqlite_exec() invokes the callback with three arguments.  The
! ** second argument is the name of the locked table and the third
! ** argument is the number of times the table has been busy.  If the
! ** busy callback returns 0, then sqlite_exec() immediately returns
! ** SQLITE_BUSY.  If the callback returns non-zero, then sqlite_exec()
! ** tries to open the table again and the cycle repeats.
! **
! ** The default busy callback is NULL.
! **
! ** Sqlite is re-entrant, so the busy handler may start a new query. 
! ** (It is not clear why anyone would every want to do this, but it
! ** is allowed, in theory.)  But the busy handler may not close the
! ** database.  Closing the database from a busy handler will delete 
! ** data structures out from under the executing query and will 
! ** probably result in a coredump.
! */
! void sqlite_busy_handler(sqlite*, int(*)(void*,const char*,int), void*);
! 
! /*
! ** This routine sets a busy handler that sleeps for a while when a
! ** table is locked.  The handler will sleep multiple times until 
! ** at least "ms" milleseconds of sleeping have been done.  After
! ** "ms" milleseconds of sleeping, the handler returns 0 which
! ** causes sqlite_exec() to return SQLITE_BUSY.
! **
! ** Calling this routine with an argument less than or equal to zero
! ** turns off all busy handlers.
! */
! void sqlite_busy_timeout(sqlite*, int ms);
! 
! /*
! ** This next routine is really just a wrapper around sqlite_exec().
! ** Instead of invoking a user-supplied callback for each row of the
! ** result, this routine remembers each row of the result in memory
! ** obtained from malloc(), then returns all of the result after the
! ** query has finished. 
! **
! ** As an example, suppose the query result where this table:
! **
! **        Name        | Age
! **        -----------------------
! **        Alice       | 43
! **        Bob         | 28
! **        Cindy       | 21
! **
! ** If the 3rd argument were &azResult then after the function returns
! ** azResult will contain the following data:
! **
! **        azResult[0] = "Name";
! **        azResult[1] = "Age";
! **        azResult[2] = "Alice";
! **        azResult[3] = "43";
! **        azResult[4] = "Bob";
! **        azResult[5] = "28";
! **        azResult[6] = "Cindy";
! **        azResult[7] = "21";
! **
! ** Notice that there is an extra row of data containing the column
! ** headers.  But the *nrow return value is still 3.  *ncolumn is
! ** set to 2.  In general, the number of values inserted into azResult
! ** will be ((*nrow) + 1)*(*ncolumn).
! **
! ** After the calling function has finished using the result, it should 
! ** pass the result data pointer to sqlite_free_table() in order to 
! ** release the memory that was malloc-ed.  Because of the way the 
! ** malloc() happens, the calling function must not try to call 
! ** malloc() directly.  Only sqlite_free_table() is able to release 
! ** the memory properly and safely.
! **
! ** The return value of this routine is the same as from sqlite_exec().
! */
! int sqlite_get_table(
!   sqlite*,               /* An open database */
!   const char *sql,       /* SQL to be executed */
!   char ***resultp,       /* Result written to a char *[]  that this points to */
!   int *nrow,             /* Number of result rows written here */
!   int *ncolumn,          /* Number of result columns written here */
!   char **errmsg          /* Error msg written here */
! );
! 
! /*
! ** Call this routine to free the memory that sqlite_get_table() allocated.
! */
! void sqlite_free_table(char **result);
! 
! /*
! ** The following routines are wrappers around sqlite_exec() and
! ** sqlite_get_table().  The only difference between the routines that
! ** follow and the originals is that the second argument to the 
! ** routines that follow is really a printf()-style format
! ** string describing the SQL to be executed.  Arguments to the format
! ** string appear at the end of the argument list.
! **
! ** All of the usual printf formatting options apply.  In addition, there
! ** is a "%q" option.  %q works like %s in that it substitutes a null-terminated
! ** string from the argument list.  But %q also doubles every '\'' character.
! ** %q is designed for use inside a string literal.  By doubling each '\''
! ** character it escapes that character and allows it to be inserted into
! ** the string.
! **
! ** For example, so some string variable contains text as follows:
! **
! **      char *zText = "It's a happy day!";
! **
! ** We can use this text in an SQL statement as follows:
! **
! **      sqlite_exec_printf(db, "INSERT INTO table VALUES('%q')",
! **          callback1, 0, 0, zText);
! **
! ** Because the %q format string is used, the '\'' character in zText
! ** is escaped and the SQL generated is as follows:
! **
! **      INSERT INTO table1 VALUES('It''s a happy day!')
! **
! ** This is correct.  Had we used %s instead of %q, the generated SQL
! ** would have looked like this:
! **
! **      INSERT INTO table1 VALUES('It's a happy day!');
! **
! ** This second example is an SQL syntax error.  As a general rule you
! ** should always use %q instead of %s when inserting text into a string 
! ** literal.
! */
! int sqlite_exec_printf(
!   sqlite*,                      /* An open database */
!   const char *sqlFormat,        /* printf-style format string for the SQL */
!   sqlite_callback,              /* Callback function */
!   void *,                       /* 1st argument to callback function */
!   char **errmsg,                /* Error msg written here */
!   ...                           /* Arguments to the format string. */
! );
! int sqlite_exec_vprintf(
!   sqlite*,                      /* An open database */
!   const char *sqlFormat,        /* printf-style format string for the SQL */
!   sqlite_callback,              /* Callback function */
!   void *,                       /* 1st argument to callback function */
!   char **errmsg,                /* Error msg written here */
!   va_list ap                    /* Arguments to the format string. */
! );
! int sqlite_get_table_printf(
!   sqlite*,               /* An open database */
!   const char *sqlFormat, /* printf-style format string for the SQL */
!   char ***resultp,       /* Result written to a char *[]  that this points to */
!   int *nrow,             /* Number of result rows written here */
!   int *ncolumn,          /* Number of result columns written here */
!   char **errmsg,         /* Error msg written here */
!   ...                    /* Arguments to the format string */
! );
! int sqlite_get_table_vprintf(
!   sqlite*,               /* An open database */
!   const char *sqlFormat, /* printf-style format string for the SQL */
!   char ***resultp,       /* Result written to a char *[]  that this points to */
!   int *nrow,             /* Number of result rows written here */
!   int *ncolumn,          /* Number of result columns written here */
!   char **errmsg,         /* Error msg written here */
!   va_list ap             /* Arguments to the format string */
! );
! char *sqlite_mprintf(const char*,...);
! char *sqlite_vmprintf(const char*, va_list);
! 
! /*
! ** Windows systems should call this routine to free memory that
! ** is returned in the in the errmsg parameter of sqlite_open() when
! ** SQLite is a DLL.  For some reason, it does not work to call free()
! ** directly.
! */
! void sqlite_freemem(void *p);
! 
! /*
! ** Windows systems need functions to call to return the sqlite_version
! ** and sqlite_encoding strings.
! */
! const char *sqlite_libversion(void);
! const char *sqlite_libencoding(void);
! 
! /*
! ** A pointer to the following structure is used to communicate with
! ** the implementations of user-defined functions.
! */
! typedef struct sqlite_func sqlite_func;
! 
! /*
! ** Use the following routines to create new user-defined functions.  See
! ** the documentation for details.
! */
! int sqlite_create_function(
!   sqlite*,                  /* Database where the new function is registered */
!   const char *zName,        /* Name of the new function */
!   int nArg,                 /* Number of arguments.  -1 means any number */
!   void (*xFunc)(sqlite_func*,int,const char**),  /* C code to implement */
!   void *pUserData           /* Available via the sqlite_user_data() call */
! );
! int sqlite_create_aggregate(
!   sqlite*,                  /* Database where the new function is registered */
!   const char *zName,        /* Name of the function */
!   int nArg,                 /* Number of arguments */
!   void (*xStep)(sqlite_func*,int,const char**), /* Called for each row */
!   void (*xFinalize)(sqlite_func*),       /* Called once to get final result */
!   void *pUserData           /* Available via the sqlite_user_data() call */
! );
! 
! /*
! ** Use the following routine to define the datatype returned by a
! ** user-defined function.  The second argument can be one of the
! ** constants SQLITE_NUMERIC, SQLITE_TEXT, or SQLITE_ARGS or it
! ** can be an integer greater than or equal to zero.  When the datatype
! ** parameter is non-negative, the type of the result will be the
! ** same as the datatype-th argument.  If datatype==SQLITE_NUMERIC
! ** then the result is always numeric.  If datatype==SQLITE_TEXT then
! ** the result is always text.  If datatype==SQLITE_ARGS then the result
! ** is numeric if any argument is numeric and is text otherwise.
! */
! int sqlite_function_type(
!   sqlite *db,               /* The database there the function is registered */
!   const char *zName,        /* Name of the function */
!   int datatype              /* The datatype for this function */
! );
! #define SQLITE_NUMERIC     (-1)
! /* #define SQLITE_TEXT     (-2)  // See below */
! #define SQLITE_ARGS        (-3)
! 
! /*
! ** SQLite version 3 defines SQLITE_TEXT differently.  To allow both
! ** version 2 and version 3 to be included, undefine them both if a
! ** conflict is seen.  Define SQLITE2_TEXT to be the version 2 value.
! */
! #ifdef SQLITE_TEXT
! # undef SQLITE_TEXT
! #else
! # define SQLITE_TEXT     (-2)
! #endif
! #define SQLITE2_TEXT     (-2)
! 
! 
! 
! /*
! ** The user function implementations call one of the following four routines
! ** in order to return their results.  The first parameter to each of these
! ** routines is a copy of the first argument to xFunc() or xFinialize().
! ** The second parameter to these routines is the result to be returned.
! ** A NULL can be passed as the second parameter to sqlite_set_result_string()
! ** in order to return a NULL result.
! **
! ** The 3rd argument to _string and _error is the number of characters to
! ** take from the string.  If this argument is negative, then all characters
! ** up to and including the first '\000' are used.
! **
! ** The sqlite_set_result_string() function allocates a buffer to hold the
! ** result and returns a pointer to this buffer.  The calling routine
! ** (that is, the implmentation of a user function) can alter the content
! ** of this buffer if desired.
! */
! char *sqlite_set_result_string(sqlite_func*,const char*,int);
! void sqlite_set_result_int(sqlite_func*,int);
! void sqlite_set_result_double(sqlite_func*,double);
! void sqlite_set_result_error(sqlite_func*,const char*,int);
! 
! /*
! ** The pUserData parameter to the sqlite_create_function() and
! ** sqlite_create_aggregate() routines used to register user functions
! ** is available to the implementation of the function using this
! ** call.
! */
! void *sqlite_user_data(sqlite_func*);
! 
! /*
! ** Aggregate functions use the following routine to allocate
! ** a structure for storing their state.  The first time this routine
! ** is called for a particular aggregate, a new structure of size nBytes
! ** is allocated, zeroed, and returned.  On subsequent calls (for the
! ** same aggregate instance) the same buffer is returned.  The implementation
! ** of the aggregate can use the returned buffer to accumulate data.
! **
! ** The buffer allocated is freed automatically be SQLite.
! */
! void *sqlite_aggregate_context(sqlite_func*, int nBytes);
! 
! /*
! ** The next routine returns the number of calls to xStep for a particular
! ** aggregate function instance.  The current call to xStep counts so this
! ** routine always returns at least 1.
! */
! int sqlite_aggregate_count(sqlite_func*);
! 
! /*
! ** This routine registers a callback with the SQLite library.  The
! ** callback is invoked (at compile-time, not at run-time) for each
! ** attempt to access a column of a table in the database.  The callback
! ** returns SQLITE_OK if access is allowed, SQLITE_DENY if the entire
! ** SQL statement should be aborted with an error and SQLITE_IGNORE
! ** if the column should be treated as a NULL value.
! */
! int sqlite_set_authorizer(
!   sqlite*,
!   int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
!   void *pUserData
! );
! 
! /*
! ** The second parameter to the access authorization function above will
! ** be one of the values below.  These values signify what kind of operation
! ** is to be authorized.  The 3rd and 4th parameters to the authorization
! ** function will be parameters or NULL depending on which of the following
! ** codes is used as the second parameter.  The 5th parameter is the name
! ** of the database ("main", "temp", etc.) if applicable.  The 6th parameter
! ** is the name of the inner-most trigger or view that is responsible for
! ** the access attempt or NULL if this access attempt is directly from 
! ** input SQL code.
! **
! **                                          Arg-3           Arg-4
! */
! #define SQLITE_COPY                  0   /* Table Name      File Name       */
! #define SQLITE_CREATE_INDEX          1   /* Index Name      Table Name      */
! #define SQLITE_CREATE_TABLE          2   /* Table Name      NULL            */
! #define SQLITE_CREATE_TEMP_INDEX     3   /* Index Name      Table Name      */
! #define SQLITE_CREATE_TEMP_TABLE     4   /* Table Name      NULL            */
! #define SQLITE_CREATE_TEMP_TRIGGER   5   /* Trigger Name    Table Name      */
! #define SQLITE_CREATE_TEMP_VIEW      6   /* View Name       NULL            */
! #define SQLITE_CREATE_TRIGGER        7   /* Trigger Name    Table Name      */
! #define SQLITE_CREATE_VIEW           8   /* View Name       NULL            */
! #define SQLITE_DELETE                9   /* Table Name      NULL            */
! #define SQLITE_DROP_INDEX           10   /* Index Name      Table Name      */
! #define SQLITE_DROP_TABLE           11   /* Table Name      NULL            */
! #define SQLITE_DROP_TEMP_INDEX      12   /* Index Name      Table Name      */
! #define SQLITE_DROP_TEMP_TABLE      13   /* Table Name      NULL            */
! #define SQLITE_DROP_TEMP_TRIGGER    14   /* Trigger Name    Table Name      */
! #define SQLITE_DROP_TEMP_VIEW       15   /* View Name       NULL            */
! #define SQLITE_DROP_TRIGGER         16   /* Trigger Name    Table Name      */
! #define SQLITE_DROP_VIEW            17   /* View Name       NULL            */
! #define SQLITE_INSERT               18   /* Table Name      NULL            */
! #define SQLITE_PRAGMA               19   /* Pragma Name     1st arg or NULL */
! #define SQLITE_READ                 20   /* Table Name      Column Name     */
! #define SQLITE_SELECT               21   /* NULL            NULL            */
! #define SQLITE_TRANSACTION          22   /* NULL            NULL            */
! #define SQLITE_UPDATE               23   /* Table Name      Column Name     */
! #define SQLITE_ATTACH               24   /* Filename        NULL            */
! #define SQLITE_DETACH               25   /* Database Name   NULL            */
! 
! 
! /*
! ** The return value of the authorization function should be one of the
! ** following constants:
! */
! /* #define SQLITE_OK  0   // Allow access (This is actually defined above) */
! #define SQLITE_DENY   1   /* Abort the SQL statement with an error */
! #define SQLITE_IGNORE 2   /* Don't allow access, but don't generate an error */
! 
! /*
! ** Register a function that is called at every invocation of sqlite_exec()
! ** or sqlite_compile().  This function can be used (for example) to generate
! ** a log file of all SQL executed against a database.
! */
! void *sqlite_trace(sqlite*, void(*xTrace)(void*,const char*), void*);
! 
! /*** The Callback-Free API
! ** 
! ** The following routines implement a new way to access SQLite that does not
! ** involve the use of callbacks.
! **
! ** An sqlite_vm is an opaque object that represents a single SQL statement
! ** that is ready to be executed.
! */
! typedef struct sqlite_vm sqlite_vm;
! 
! /*
! ** To execute an SQLite query without the use of callbacks, you first have
! ** to compile the SQL using this routine.  The 1st parameter "db" is a pointer
! ** to an sqlite object obtained from sqlite_open().  The 2nd parameter
! ** "zSql" is the text of the SQL to be compiled.   The remaining parameters
! ** are all outputs.
! **
! ** *pzTail is made to point to the first character past the end of the first
! ** SQL statement in zSql.  This routine only compiles the first statement
! ** in zSql, so *pzTail is left pointing to what remains uncompiled.
! **
! ** *ppVm is left pointing to a "virtual machine" that can be used to execute
! ** the compiled statement.  Or if there is an error, *ppVm may be set to NULL.
! ** If the input text contained no SQL (if the input is and empty string or
! ** a comment) then *ppVm is set to NULL.
! **
! ** If any errors are detected during compilation, an error message is written
! ** into space obtained from malloc() and *pzErrMsg is made to point to that
! ** error message.  The calling routine is responsible for freeing the text
! ** of this message when it has finished with it.  Use sqlite_freemem() to
! ** free the message.  pzErrMsg may be NULL in which case no error message
! ** will be generated.
! **
! ** On success, SQLITE_OK is returned.  Otherwise and error code is returned.
! */
! int sqlite_compile(
!   sqlite *db,                   /* The open database */
!   const char *zSql,             /* SQL statement to be compiled */
!   const char **pzTail,          /* OUT: uncompiled tail of zSql */
!   sqlite_vm **ppVm,             /* OUT: the virtual machine to execute zSql */
!   char **pzErrmsg               /* OUT: Error message. */
! );
! 
! /*
! ** After an SQL statement has been compiled, it is handed to this routine
! ** to be executed.  This routine executes the statement as far as it can
! ** go then returns.  The return value will be one of SQLITE_DONE,
! ** SQLITE_ERROR, SQLITE_BUSY, SQLITE_ROW, or SQLITE_MISUSE.
! **
! ** SQLITE_DONE means that the execute of the SQL statement is complete
! ** an no errors have occurred.  sqlite_step() should not be called again
! ** for the same virtual machine.  *pN is set to the number of columns in
! ** the result set and *pazColName is set to an array of strings that
! ** describe the column names and datatypes.  The name of the i-th column
! ** is (*pazColName)[i] and the datatype of the i-th column is
! ** (*pazColName)[i+*pN].  *pazValue is set to NULL.
! **
! ** SQLITE_ERROR means that the virtual machine encountered a run-time
! ** error.  sqlite_step() should not be called again for the same
! ** virtual machine.  *pN is set to 0 and *pazColName and *pazValue are set
! ** to NULL.  Use sqlite_finalize() to obtain the specific error code
! ** and the error message text for the error.
! **
! ** SQLITE_BUSY means that an attempt to open the database failed because
! ** another thread or process is holding a lock.  The calling routine
! ** can try again to open the database by calling sqlite_step() again.
! ** The return code will only be SQLITE_BUSY if no busy handler is registered
! ** using the sqlite_busy_handler() or sqlite_busy_timeout() routines.  If
! ** a busy handler callback has been registered but returns 0, then this
! ** routine will return SQLITE_ERROR and sqltie_finalize() will return
! ** SQLITE_BUSY when it is called.
! **
! ** SQLITE_ROW means that a single row of the result is now available.
! ** The data is contained in *pazValue.  The value of the i-th column is
! ** (*azValue)[i].  *pN and *pazColName are set as described in SQLITE_DONE.
! ** Invoke sqlite_step() again to advance to the next row.
! **
! ** SQLITE_MISUSE is returned if sqlite_step() is called incorrectly.
! ** For example, if you call sqlite_step() after the virtual machine
! ** has halted (after a prior call to sqlite_step() has returned SQLITE_DONE)
! ** or if you call sqlite_step() with an incorrectly initialized virtual
! ** machine or a virtual machine that has been deleted or that is associated
! ** with an sqlite structure that has been closed.
! */
! int sqlite_step(
!   sqlite_vm *pVm,              /* The virtual machine to execute */
!   int *pN,                     /* OUT: Number of columns in result */
!   const char ***pazValue,      /* OUT: Column data */
!   const char ***pazColName     /* OUT: Column names and datatypes */
! );
! 
! /*
! ** This routine is called to delete a virtual machine after it has finished
! ** executing.  The return value is the result code.  SQLITE_OK is returned
! ** if the statement executed successfully and some other value is returned if
! ** there was any kind of error.  If an error occurred and pzErrMsg is not
! ** NULL, then an error message is written into memory obtained from malloc()
! ** and *pzErrMsg is made to point to that error message.  The calling routine
! ** should use sqlite_freemem() to delete this message when it has finished
! ** with it.
! **
! ** This routine can be called at any point during the execution of the
! ** virtual machine.  If the virtual machine has not completed execution
! ** when this routine is called, that is like encountering an error or
! ** an interrupt.  (See sqlite_interrupt().)  Incomplete updates may be
! ** rolled back and transactions cancelled,  depending on the circumstances,
! ** and the result code returned will be SQLITE_ABORT.
! */
! int sqlite_finalize(sqlite_vm*, char **pzErrMsg);
! 
! /*
! ** This routine deletes the virtual machine, writes any error message to
! ** *pzErrMsg and returns an SQLite return code in the same way as the
! ** sqlite_finalize() function.
! **
! ** Additionally, if ppVm is not NULL, *ppVm is left pointing to a new virtual
! ** machine loaded with the compiled version of the original query ready for
! ** execution.
! **
! ** If sqlite_reset() returns SQLITE_SCHEMA, then *ppVm is set to NULL.
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! int sqlite_reset(sqlite_vm*, char **pzErrMsg);
! 
! /*
! ** If the SQL that was handed to sqlite_compile contains variables that
! ** are represeted in the SQL text by a question mark ('?').  This routine
! ** is used to assign values to those variables.
! **
! ** The first parameter is a virtual machine obtained from sqlite_compile().
! ** The 2nd "idx" parameter determines which variable in the SQL statement
! ** to bind the value to.  The left most '?' is 1.  The 3rd parameter is
! ** the value to assign to that variable.  The 4th parameter is the number
! ** of bytes in the value, including the terminating \000 for strings.
! ** Finally, the 5th "copy" parameter is TRUE if SQLite should make its
! ** own private copy of this value, or false if the space that the 3rd
! ** parameter points to will be unchanging and can be used directly by
! ** SQLite.
! **
! ** Unbound variables are treated as having a value of NULL.  To explicitly
! ** set a variable to NULL, call this routine with the 3rd parameter as a
! ** NULL pointer.
! **
! ** If the 4th "len" parameter is -1, then strlen() is used to find the
! ** length.
! **
! ** This routine can only be called immediately after sqlite_compile()
! ** or sqlite_reset() and before any calls to sqlite_step().
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! int sqlite_bind(sqlite_vm*, int idx, const char *value, int len, int copy);
! 
! /*
! ** This routine configures a callback function - the progress callback - that
! ** is invoked periodically during long running calls to sqlite_exec(),
! ** sqlite_step() and sqlite_get_table(). An example use for this API is to keep
! ** a GUI updated during a large query.
! **
! ** The progress callback is invoked once for every N virtual machine opcodes,
! ** where N is the second argument to this function. The progress callback
! ** itself is identified by the third argument to this function. The fourth
! ** argument to this function is a void pointer passed to the progress callback
! ** function each time it is invoked.
! **
! ** If a call to sqlite_exec(), sqlite_step() or sqlite_get_table() results 
! ** in less than N opcodes being executed, then the progress callback is not
! ** invoked.
! ** 
! ** Calling this routine overwrites any previously installed progress callback.
! ** To remove the progress callback altogether, pass NULL as the third
! ** argument to this function.
! **
! ** If the progress callback returns a result other than 0, then the current 
! ** query is immediately terminated and any database changes rolled back. If the
! ** query was part of a larger transaction, then the transaction is not rolled
! ** back and remains active. The sqlite_exec() call returns SQLITE_ABORT. 
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! void sqlite_progress_handler(sqlite*, int, int(*)(void*), void*);
! 
! /*
! ** Register a callback function to be invoked whenever a new transaction
! ** is committed.  The pArg argument is passed through to the callback.
! ** callback.  If the callback function returns non-zero, then the commit
! ** is converted into a rollback.
! **
! ** If another function was previously registered, its pArg value is returned.
! ** Otherwise NULL is returned.
! **
! ** Registering a NULL function disables the callback.
! **
! ******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******
! */
! void *sqlite_commit_hook(sqlite*, int(*)(void*), void*);
! 
! /*
! ** Open an encrypted SQLite database.  If pKey==0 or nKey==0, this routine
! ** is the same as sqlite_open().
! **
! ** The code to implement this API is not available in the public release
! ** of SQLite.
! */
! sqlite *sqlite_open_encrypted(
!   const char *zFilename,   /* Name of the encrypted database */
!   const void *pKey,        /* Pointer to the key */
!   int nKey,                /* Number of bytes in the key */
!   int *pErrcode,           /* Write error code here */
!   char **pzErrmsg          /* Write error message here */
! );
! 
! /*
! ** Change the key on an open database.  If the current database is not
! ** encrypted, this routine will encrypt it.  If pNew==0 or nNew==0, the
! ** database is decrypted.
! **
! ** The code to implement this API is not available in the public release
! ** of SQLite.
! */
! int sqlite_rekey(
!   sqlite *db,                    /* Database to be rekeyed */
!   const void *pKey, int nKey     /* The new key */
! );
! 
! /*
! ** Encode a binary buffer "in" of size n bytes so that it contains
! ** no instances of characters '\'' or '\000'.  The output is 
! ** null-terminated and can be used as a string value in an INSERT
! ** or UPDATE statement.  Use sqlite_decode_binary() to convert the
! ** string back into its original binary.
! **
! ** The result is written into a preallocated output buffer "out".
! ** "out" must be able to hold at least 2 +(257*n)/254 bytes.
! ** In other words, the output will be expanded by as much as 3
! ** bytes for every 254 bytes of input plus 2 bytes of fixed overhead.
! ** (This is approximately 2 + 1.0118*n or about a 1.2% size increase.)
! **
! ** The return value is the number of characters in the encoded
! ** string, excluding the "\000" terminator.
! **
! ** If out==NULL then no output is generated but the routine still returns
! ** the number of characters that would have been generated if out had
! ** not been NULL.
! */
! int sqlite_encode_binary(const unsigned char *in, int n, unsigned char *out);
! 
! /*
! ** Decode the string "in" into binary data and write it into "out".
! ** This routine reverses the encoding created by sqlite_encode_binary().
! ** The output will always be a few bytes less than the input.  The number
! ** of bytes of output is returned.  If the input is not a well-formed
! ** encoding, -1 is returned.
! **
! ** The "in" and "out" parameters may point to the same buffer in order
! ** to decode a string in place.
! */
! int sqlite_decode_binary(const unsigned char *in, unsigned char *out);
! 
! #ifdef __cplusplus
! }  /* End of the 'extern "C"' block */
! #endif
! 
! #endif /* _SQLITE_H_ */
diff -c ../sqlite-2.8.17/src/sqliteInt.h src/sqliteInt.h
*** ../sqlite-2.8.17/src/sqliteInt.h	2005-06-06 11:07:03.000000000 -0400
--- src/sqliteInt.h	2013-06-01 13:15:13.000000000 -0400
***************
*** 245,254 ****
  typedef struct FuncDef FuncDef;
  typedef struct Trigger Trigger;
  typedef struct TriggerStep TriggerStep;
! typedef struct TriggerStack TriggerStack;
  typedef struct FKey FKey;
  typedef struct Db Db;
  typedef struct AuthContext AuthContext;
  
  /*
  ** Each database file to be accessed by the system is an instance
--- 245,260 ----
  typedef struct FuncDef FuncDef;
  typedef struct Trigger Trigger;
  typedef struct TriggerStep TriggerStep;
! typedef struct TriggerStack TriggerStack;
  typedef struct FKey FKey;
  typedef struct Db Db;
  typedef struct AuthContext AuthContext;
+ typedef struct Variable Variable;
+ typedef struct Stmt Stmt;
+ typedef struct SQLStmt SQLStmt;
+ typedef struct StmtList StmtList;
+ typedef struct Block Block;
+ typedef struct Object Object;
  
  /*
  ** Each database file to be accessed by the system is an instance
***************
*** 264,269 ****
--- 270,276 ----
    Hash tblHash;        /* All tables indexed by name */
    Hash idxHash;        /* All (named) indices indexed by name */
    Hash trigHash;       /* All triggers indexed by name */
+   Hash objectHash;     /* All objects indexed by name */
    Hash aFKey;          /* Foreign keys indexed by to-table */
    u8 inTrans;          /* 0: not writable.  1: Transaction.  2: Checkpoint */
    u16 flags;           /* Flags associated with this database */
***************
*** 383,388 ****
--- 390,396 ----
    void *pProgressArg;           /* Argument to the progress callback */
    int nProgressOps;             /* Number of opcodes for progress callback */
  #endif
+   FKey *pDeferredFKeys;					/* Linked list of foreign key deferred DDL work */
  };
  
  /*
***************
*** 538,545 ****
--- 546,555 ----
  struct FKey {
    Table *pFrom;     /* The table that constains the REFERENCES clause */
    FKey *pNextFrom;  /* Next foreign key in pFrom */
+ 	int nId;					/* Sequence number of this FKey (used in name generation) */
    char *zTo;        /* Name of table that the key points to */
    FKey *pNextTo;    /* Next foreign key that points to zTo */
+   FKey *pNextDef;   /* Next foreign key in deferred DDL work list */
    int nCol;         /* Number of columns in this key */
    struct sColMap {  /* Mapping of columns in pFrom to columns in zTo */
      int iFrom;         /* Index of column in pFrom */
***************
*** 700,705 ****
--- 710,716 ----
  ** The following are the meanings of bits in the Expr.flags field.
  */
  #define EP_FromJoin     0x0001  /* Originated in ON or USING clause of a join */
+ #define EP_NotNull      0x0002  /* VAR node for Not Null variable */
  
  /*
  ** These macros can be used to test, set, or clear bits in the 
***************
*** 714,722 ****
  ** A list of expressions.  Each expression may optionally have a
  ** name.  An expr/name combination can be used in several ways, such
  ** as the list of "expr AS ID" fields following a "SELECT" or in the
! ** list of "ID = expr" items in an UPDATE.  A list of expressions can
  ** also be used as the argument to a function, in which case the a.zName
! ** field is not used.
  */
  struct ExprList {
    int nExpr;             /* Number of expressions on the list */
--- 725,733 ----
  ** A list of expressions.  Each expression may optionally have a
  ** name.  An expr/name combination can be used in several ways, such
  ** as the list of "expr AS ID" fields following a "SELECT" or in the
! ** list of "ID = expr" items in an UPDATE. A list of expressions can
  ** also be used as the argument to a function, in which case the a.zName
! ** field is not used. 
  */
  struct ExprList {
    int nExpr;             /* Number of expressions on the list */
***************
*** 875,880 ****
--- 886,892 ----
  #define SRT_Discard      9  /* Do not save the results anywhere */
  #define SRT_Sorter      10  /* Store results in the sorter */
  #define SRT_Subroutine  11  /* Call a subroutine to handle results */
+ #define SRT_Stack       12  /* Leave result on the stack */
  
  /*
  ** When a SELECT uses aggregate functions (like "count(*)" or "avg(f1)")
***************
*** 910,915 ****
--- 922,928 ----
    sqlite *db;          /* The main database structure */
    int rc;              /* Return code from execution */
    char *zErrMsg;       /* An error message */
+   char *zWarning;      /* A warning message */
    Token sErrToken;     /* The token at which the error occurred */
    Token sFirstToken;   /* The first token parsed */
    Token sLastToken;    /* The last token parsed */
***************
*** 931,936 ****
--- 944,952 ----
    const char *zAuthContext; /* The 6th parameter to db->xAuth callbacks */
    Trigger *pNewTrigger;     /* Trigger under construct by a CREATE TRIGGER */
    TriggerStack *trigStack;  /* Trigger actions being coded */
+   Block *pCurrentBlock; 	/* Frame of innermost procedure block being coded */
+   Object *pNewObject;		/* Object under construct by a CREATE ... */
+   int iLoopExit;        /* Target label of EXIT jump; 0 means we're not inside a loop */
  };
  
  /*
***************
*** 1073,1078 ****
--- 1089,1169 ----
  };
  
  /*
+ ** Each node of a variable list in the parse tree is an instance
+ ** of this structure.
+ **
+ */
+ struct Variable {
+   char *zName;     /* Name of this variable */
+   Expr *pDflt;     /* Default value of this variable */
+   char *zType;     /* Data type for this variable */
+   int mVar;		   /* memory cell number of variable */
+   u8 notNull;      /* True if there is a NOT NULL constraint */
+   u8 isParam;	   /* True if this is a parameter */
+ };
+ 
+ /*
+ ** Each node of a statement list in the parse tree is an instance
+ ** of this structure.
+ **
+ */
+ struct Stmt {
+   int op;            /* Type of statement, e.g. TK_IF, TK_WHILE, TK_SQL, etc. */
+   Expr *pExpr1;      /* Statement expression */
+   StmtList *pStmt1;	 /* First sub-statements */
+   Stmt *pStmt2;	     /* Second sub-statement (used for IF & CASE)*/
+   Block *pBlock;	   /* Block, if this statement is a sub-block */
+   SQLStmt *pSql;	   /* SQL statement details, if this is one */
+ };
+ 
+ struct SQLStmt {
+   int op;              /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */
+   int orconf;          /* OE_Rollback etc. */
+   Select *pSelect;     /* Valid for SELECT and sometimes 
+ 						  INSERT steps (when pExprList == 0) */
+   Token target;        /* Valid for DELETE, UPDATE, INSERT steps */
+   Expr *pWhere;        /* Valid for DELETE, UPDATE steps */
+   ExprList *pExprList; /* Valid for UPDATE statements and sometimes 
+ 						  INSERT steps (when pSelect == 0)         */
+   IdList *pIdList;     /* Valid for INSERT statements only */
+ };
+ 
+ /*
+ ** A list of statements.
+ */
+ struct StmtList {
+   int nStmt;             /* Number of expressions on the list */
+   int nAlloc;            /* Number of entries allocated below */
+   struct StmtList_item {
+     Stmt *pStmt;         /* The list of statements */
+   } *a;                  /* One entry for each expression */
+ };
+ 
+ /*
+  * An instance of struct ProcStack stores information required during code
+  */
+ struct Block {
+   int nVar;        /* Number of local variables in this block */
+   Variable *aVar;  /* Detail of each local variable */
+   int mReturn;     /* Number of memory cell with return value */
+   int nExit;       /* Label no. of halt statement */
+   int params;	   /* True while parsing parameters */
+   Object *pObj;	   /* Object this body belongs to, if any */
+   StmtList *pStList; /* List of statements in this block */
+   StmtList *pExList; /* List of exception handlers in this block */
+   Block *pParent;  /* Enclosing block, or null if current is outermost */
+ };
+ 
+ struct Object {
+   char *name;             /* The name of the object                      */
+   u8 iDb;                 /* Database containing this object             */
+   u8 what;                /* One of TK_PROCEDURE, TK_FUNCTION            */
+   int nParam;			  /* Number of parameters                        */
+   int nOp;                /* Number of instructions in the program       */
+   VdbeOp *aOp;            /* Space to hold the vdbe program              */
+ };
+ 
+ /*
  ** The following structure contains information used by the sqliteFix...
  ** routines as they walk the parse tree to make database references
  ** explicit.  
***************
*** 1158,1164 ****
  IdList *sqliteIdListAppend(IdList*, Token*);
  int sqliteIdListIndex(IdList*,const char*);
  SrcList *sqliteSrcListAppend(SrcList*, Token*, Token*);
! void sqliteSrcListAddAlias(SrcList*, Token*);
  void sqliteSrcListAssignCursors(Parse*, SrcList*);
  void sqliteIdListDelete(IdList*);
  void sqliteSrcListDelete(SrcList*);
--- 1249,1255 ----
  IdList *sqliteIdListAppend(IdList*, Token*);
  int sqliteIdListIndex(IdList*,const char*);
  SrcList *sqliteSrcListAppend(SrcList*, Token*, Token*);
! void sqliteSrcListAddAlias(SrcList*, Token*);
  void sqliteSrcListAssignCursors(Parse*, SrcList*);
  void sqliteIdListDelete(IdList*);
  void sqliteSrcListDelete(SrcList*);
***************
*** 1268,1270 ****
--- 1359,1386 ----
  double sqliteAtoF(const char *z, const char **);
  char *sqlite_snprintf(int,char*,const char*,...);
  int sqliteFitsIn32Bits(const char *);
+ 
+ void sqliteProc(Parse *pParse, ExprList *pList);
+ void sqliteStartBlock(Parse*, int);
+ Block *sqliteEndBlock(Parse*, StmtList*, StmtList*);
+ void sqliteStmtListDelete(StmtList *pList);
+ void sqliteBlockDelete(Block *pBlock);
+ void sqliteAddProcVar(Parse *pParse, Token *pName);
+ void sqliteAddProcVarType(Parse *pParse, Token *pFirst, Token *pLast);
+ void sqliteAddProcVarExpr(Parse *pParse, Expr *pExpr1, int notnull);
+ int sqliteLookupVar(Parse*, Block*, Expr*);
+ Stmt* sqliteStmt(Parse*, int, Expr*, StmtList*, Stmt*, Block*);
+ void sqliteStmtDelete(Stmt *p);
+ StmtList *sqliteStmtListAppend(StmtList *pList, Stmt *pStmt);
+ void sqliteStmtListDelete(StmtList *pList);
+ Stmt *sqliteSQLStmt(int, Token *, IdList *, ExprList *, Select *, Expr *, int);
+ 
+ void sqliteFinishProc(Parse*, Block*, Token*);
+ void sqliteBeginProc(Parse*, int, Token*);
+ void sqliteDropProc(Parse*, Token*);
+ void sqliteDeleteObject(Object*);
+ void sqliteDropProcPtr(Parse*, Object*);
+ void sqliteExecProc(Parse*, Token*, ExprList*);
+ void sqliteExecBlock(Parse*, Block*);
+ 
+ int sqliteDoDefDDL(sqlite*, char**);
diff -c ../sqlite-2.8.17/src/test1.c src/test1.c
*** ../sqlite-2.8.17/src/test1.c	2005-04-23 18:43:22.000000000 -0400
--- src/test1.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 968,974 ****
  }
  
  /*
! ** Register commands with the TCL interpreter.
  */
  int Sqlitetest1_Init(Tcl_Interp *interp){
    extern int sqlite_search_count;
--- 968,974 ----
  }
  
  /*
! ** Register commands with the TCL interpreter.
  */
  int Sqlitetest1_Init(Tcl_Interp *interp){
    extern int sqlite_search_count;
diff -c ../sqlite-2.8.17/src/test2.c src/test2.c
*** ../sqlite-2.8.17/src/test2.c	2005-04-23 18:43:22.000000000 -0400
--- src/test2.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 273,279 ****
        "ref", "page", "max", "size", "state", "err",
        "hit", "miss", "ovfl",
      };
!     char zBuf[100];
      Tcl_AppendElement(interp, zName[i]);
      sprintf(zBuf,"%d",a[i]);
      Tcl_AppendElement(interp, zBuf);
--- 273,279 ----
        "ref", "page", "max", "size", "state", "err",
        "hit", "miss", "ovfl",
      };
!     char zBuf[100];
      Tcl_AppendElement(interp, zName[i]);
      sprintf(zBuf,"%d",a[i]);
      Tcl_AppendElement(interp, zBuf);
diff -c ../sqlite-2.8.17/src/test3.c src/test3.c
*** ../sqlite-2.8.17/src/test3.c	2005-04-23 18:43:22.000000000 -0400
--- src/test3.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 847,853 ****
  
    if( argc!=2 ){
      Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
!        " ID\"", 0);
      return TCL_ERROR;
    }
    if( Tcl_GetInt(interp, argv[1], (int*)&pCur) ) return TCL_ERROR;
--- 847,853 ----
  
    if( argc!=2 ){
      Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
!        " ID\"", 0);
      return TCL_ERROR;
    }
    if( Tcl_GetInt(interp, argv[1], (int*)&pCur) ) return TCL_ERROR;
diff -c ../sqlite-2.8.17/src/tokenize.c src/tokenize.c
*** ../sqlite-2.8.17/src/tokenize.c	2005-04-23 18:43:22.000000000 -0400
--- src/tokenize.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 61,66 ****
--- 61,67 ----
    { "CREATE",            TK_CREATE,       },
    { "CROSS",             TK_JOIN_KW,      },
    { "DATABASE",          TK_DATABASE,     },
+   { "DECLARE",           TK_DECLARE,      },
    { "DEFAULT",           TK_DEFAULT,      },
    { "DEFERRED",          TK_DEFERRED,     },
    { "DEFERRABLE",        TK_DEFERRABLE,   },
***************
*** 73,79 ****
--- 74,84 ----
    { "END",               TK_END,          },
    { "EACH",              TK_EACH,         },
    { "ELSE",              TK_ELSE,         },
+   { "ELSIF",             TK_ELSIF,        },
    { "EXCEPT",            TK_EXCEPT,       },
+   { "EXCEPTION",         TK_EXCEPTION,    },
+   { "EXEC",              TK_EXEC,         },
+   { "EXIT",              TK_EXIT,         },
    { "EXPLAIN",           TK_EXPLAIN,      },
    { "FAIL",              TK_FAIL,         },
    { "FOR",               TK_FOR,          },
***************
*** 93,98 ****
--- 98,104 ----
    { "INSTEAD",           TK_INSTEAD,      },
    { "INTERSECT",         TK_INTERSECT,    },
    { "INTO",              TK_INTO,         },
+   { "IF",                TK_IF,           },
    { "IS",                TK_IS,           },
    { "ISNULL",            TK_ISNULL,       },
    { "JOIN",              TK_JOIN,         },
***************
*** 100,105 ****
--- 106,112 ----
    { "LEFT",              TK_JOIN_KW,      },
    { "LIKE",              TK_LIKE,         },
    { "LIMIT",             TK_LIMIT,        },
+   { "LOOP",              TK_LOOP,         },
    { "MATCH",             TK_MATCH,        },
    { "NATURAL",           TK_JOIN_KW,      },
    { "NOT",               TK_NOT,          },
***************
*** 110,121 ****
--- 117,132 ----
    { "ON",                TK_ON,           },
    { "OR",                TK_OR,           },
    { "ORDER",             TK_ORDER,        },
+   { "OTHERS",            TK_OTHERS,       },
    { "OUTER",             TK_JOIN_KW,      },
    { "PRAGMA",            TK_PRAGMA,       },
    { "PRIMARY",           TK_PRIMARY,      },
+   { "PRINT",             TK_PRINT,        },
+   { "PROCEDURE",         TK_PROCEDURE,    },
    { "RAISE",             TK_RAISE,        },
    { "REFERENCES",        TK_REFERENCES,   },
    { "REPLACE",           TK_REPLACE,      },
+   { "RETURN",            TK_RETURN,       },
    { "RESTRICT",          TK_RESTRICT,     },
    { "RIGHT",             TK_JOIN_KW,      },
    { "ROLLBACK",          TK_ROLLBACK,     },
***************
*** 138,143 ****
--- 149,155 ----
    { "VIEW",              TK_VIEW,         },
    { "WHEN",              TK_WHEN,         },
    { "WHERE",             TK_WHERE,        },
+   { "WHILE",             TK_WHILE,        }
  };
  
  /*
***************
*** 244,249 ****
--- 256,265 ----
        *tokenType = TK_SEMI;
        return 1;
      }
+     case ':': {
+       *tokenType = TK_COLON;
+       return 1;
+     }
      case '+': {
        *tokenType = TK_PLUS;
        return 1;
***************
*** 343,350 ****
        return i;
      }
      case '.': {
!       *tokenType = TK_DOT;
!       return 1;
      }
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9': {
--- 359,371 ----
        return i;
      }
      case '.': {
!       if( z[1]=='.' ){
!         *tokenType = TK_DOTDOT;
!         return 2;
!       }else{
!         *tokenType = TK_DOT;
!         return 1;
! 	  }
      }
      case '0': case '1': case '2': case '3': case '4':
      case '5': case '6': case '7': case '8': case '9': {
***************
*** 474,479 ****
--- 495,508 ----
      pParse->zErrMsg = 0;
      if( !nErr ) nErr++;
    }
+   if( pParse->zWarning ){
+     if( pzErrMsg && *pzErrMsg==0 ){
+       *pzErrMsg = pParse->zWarning;
+     }else{
+       sqliteFree(pParse->zWarning);
+     }
+     pParse->zWarning = 0;
+   }
    if( pParse->pVdbe && pParse->nErr>0 ){
      sqliteVdbeDelete(pParse->pVdbe);
      pParse->pVdbe = 0;
***************
*** 499,505 ****
  #define tkEXPLAIN 0
  #define tkCREATE  1
  #define tkTEMP    2
! #define tkTRIGGER 3
  #define tkEND     4
  #define tkSEMI    5
  #define tkWS      6
--- 528,534 ----
  #define tkEXPLAIN 0
  #define tkCREATE  1
  #define tkTEMP    2
! #define tkCODE    3
  #define tkEND     4
  #define tkSEMI    5
  #define tkWS      6
***************
*** 508,516 ****
  /*
  ** Return TRUE if the given SQL string ends in a semicolon.
  **
! ** Special handling is require for CREATE TRIGGER statements.
! ** Whenever the CREATE TRIGGER keywords are seen, the statement
! ** must end with ";END;".
  **
  ** This implementation uses a state machine with 7 states:
  **
--- 537,545 ----
  /*
  ** Return TRUE if the given SQL string ends in a semicolon.
  **
! ** Special handling is require for CREATE TRIGGER and other statements with
! ** code bodies. Whenever statements are seen, the statement must match each
! ** BEGIN with a matching ";END;".
  **
  ** This implementation uses a state machine with 7 states:
  **
***************
*** 528,534 ****
  **   (3) NORMAL    We are in the middle of statement which ends with a single
  **                 semicolon.
  **
! **   (4) TRIGGER   We are in the middle of a trigger definition that must be
  **                 ended by a semicolon, the keyword END, and another semicolon.
  **
  **   (5) SEMI      We've seen the first semicolon in the ";END;" that occurs at
--- 557,563 ----
  **   (3) NORMAL    We are in the middle of statement which ends with a single
  **                 semicolon.
  **
! **   (4) CODE      We are in the middle of a procedural definition that must be
  **                 ended by a semicolon, the keyword END, and another semicolon.
  **
  **   (5) SEMI      We've seen the first semicolon in the ";END;" that occurs at
***************
*** 537,549 ****
  **   (6) END       We've seen the ";END" of the ";END;" that occurs at the end
  **                 of a trigger difinition.
  **
  ** Transitions between states above are determined by tokens extracted
  ** from the input.  The following tokens are significant:
  **
  **   (0) tkEXPLAIN   The "explain" keyword.
  **   (1) tkCREATE    The "create" keyword.
  **   (2) tkTEMP      The "temp" or "temporary" keyword.
! **   (3) tkTRIGGER   The "trigger" keyword.
  **   (4) tkEND       The "end" keyword.
  **   (5) tkSEMI      A semicolon.
  **   (6) tkWS        Whitespace
--- 566,582 ----
  **   (6) END       We've seen the ";END" of the ";END;" that occurs at the end
  **                 of a trigger difinition.
  **
+ ** If we encounter the BEGIN keyword we increment the nesting level. If we
+ ** encounter ;END; we decrease it. If we reach nesting level 0, we change to
+ ** state (0) START, else we continue with state (4) CODE.
+ **
  ** Transitions between states above are determined by tokens extracted
  ** from the input.  The following tokens are significant:
  **
  **   (0) tkEXPLAIN   The "explain" keyword.
  **   (1) tkCREATE    The "create" keyword.
  **   (2) tkTEMP      The "temp" or "temporary" keyword.
! **   (3) tkCODE      The "trigger", "exec" or "procedure" keyword.
  **   (4) tkEND       The "end" keyword.
  **   (5) tkSEMI      A semicolon.
  **   (6) tkWS        Whitespace
***************
*** 552,574 ****
  ** Whitespace never causes a state transition and is always ignored.
  */
  int sqlite_complete(const char *zSql){
!   u8 state = 0;   /* Current state, using numbers defined in header comment */
!   u8 token;       /* Value of the next token */
  
    /* The following matrix defines the transition from one state to another
    ** according to what token is seen.  trans[state][token] returns the
    ** next state.
    */
    static const u8 trans[7][8] = {
!                      /* Token:                                                */
!      /* State:       **  EXPLAIN  CREATE  TEMP  TRIGGER  END  SEMI  WS  OTHER */
!      /* 0   START: */ {       1,      2,    3,       3,   3,    0,  0,     3, },
!      /* 1 EXPLAIN: */ {       3,      2,    3,       3,   3,    0,  1,     3, },
!      /* 2  CREATE: */ {       3,      3,    2,       4,   3,    0,  2,     3, },
!      /* 3  NORMAL: */ {       3,      3,    3,       3,   3,    0,  3,     3, },
!      /* 4 TRIGGER: */ {       4,      4,    4,       4,   4,    5,  4,     4, },
!      /* 5    SEMI: */ {       4,      4,    4,       4,   6,    5,  5,     4, },
!      /* 6     END: */ {       4,      4,    4,       4,   4,    0,  6,     4, },
    };
  
    while( *zSql ){
--- 585,608 ----
  ** Whitespace never causes a state transition and is always ignored.
  */
  int sqlite_complete(const char *zSql){
!   u8  state = 0;   /* Current state, using numbers defined in header comment */
!   u8  token;       /* Value of the next token */
!   int nesting = 0; /* Number of BEGIN keywords seen so far */
  
    /* The following matrix defines the transition from one state to another
    ** according to what token is seen.  trans[state][token] returns the
    ** next state.
    */
    static const u8 trans[7][8] = {
!                      /* Token:                                             */
!      /* State:       **  EXPLAIN  CREATE  TEMP  CODE  END  SEMI  WS  OTHER */
!      /* 0   START: */ {       1,      2,    3,    3,   3,    0,  0,     3, },
!      /* 1 EXPLAIN: */ {       3,      2,    3,    3,   3,    0,  1,     3, },
!      /* 2  CREATE: */ {       3,      3,    2,    4,   3,    0,  2,     3, },
!      /* 3  NORMAL: */ {       3,      3,    3,    3,   3,    0,  3,     3, },
!      /* 4    CODE: */ {       4,      4,    4,    4,   4,    5,  4,     4, },
!      /* 5    SEMI: */ {       4,      4,    4,    4,   6,    5,  5,     4, },
!      /* 6     END: */ {       4,      4,    4,    4,   4,    0,  6,     4, },
    };
  
    while( *zSql ){
***************
*** 629,634 ****
--- 663,675 ----
            int nId;
            for(nId=1; isIdChar[(u8)zSql[nId]]; nId++){}
            switch( *zSql ){
+             case 'b': case 'B': {
+               if( nId==5 && sqliteStrNICmp(zSql, "begin", 5)==0 ){
+                 nesting++;
+               }
+               token = tkOTHER;
+               break;
+             }
              case 'c': case 'C': {
                if( nId==6 && sqliteStrNICmp(zSql, "create", 6)==0 ){
                  token = tkCREATE;
***************
*** 639,645 ****
              }
              case 't': case 'T': {
                if( nId==7 && sqliteStrNICmp(zSql, "trigger", 7)==0 ){
!                 token = tkTRIGGER;
                }else if( nId==4 && sqliteStrNICmp(zSql, "temp", 4)==0 ){
                  token = tkTEMP;
                }else if( nId==9 && sqliteStrNICmp(zSql, "temporary", 9)==0 ){
--- 680,686 ----
              }
              case 't': case 'T': {
                if( nId==7 && sqliteStrNICmp(zSql, "trigger", 7)==0 ){
!                 token = tkCODE;
                }else if( nId==4 && sqliteStrNICmp(zSql, "temp", 4)==0 ){
                  token = tkTEMP;
                }else if( nId==9 && sqliteStrNICmp(zSql, "temporary", 9)==0 ){
***************
*** 649,659 ****
--- 690,711 ----
                }
                break;
              }
+             case 'p': case 'P': {
+               if( nId==9 && sqliteStrNICmp(zSql, "procedure", 9)==0 ){
+                 token = tkCODE;
+               }else{
+                 token = tkOTHER;
+               }
+               break;
+             }
              case 'e':  case 'E': {
                if( nId==3 && sqliteStrNICmp(zSql, "end", 3)==0 ){
                  token = tkEND;
                }else if( nId==7 && sqliteStrNICmp(zSql, "explain", 7)==0 ){
                  token = tkEXPLAIN;
+               }else if( nId==4 && sqliteStrNICmp(zSql, "exec", 4)==0 ){
+                 if( state<2 ) state = 2;
+                 token = tkCODE;
                }else{
                  token = tkOTHER;
                }
***************
*** 672,678 ****
          break;
        }
      }
!     state = trans[state][token];
      zSql++;
    }
    return state==0;
--- 724,736 ----
          break;
        }
      }
!     if( token==tkSEMI && state==6 ) {
!       nesting--;
!       /* ignore nested ";END;" */
!       state = (nesting>0) ? 5 : 0;
!     } else {
!       state = trans[state][token];
!     }
      zSql++;
    }
    return state==0;
diff -c ../sqlite-2.8.17/src/trigger.c src/trigger.c
*** ../sqlite-2.8.17/src/trigger.c	2005-04-23 18:43:22.000000000 -0400
--- src/trigger.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 439,445 ****
      const char *zDb = db->aDb[pTrigger->iDb].zName;
      const char *zTab = SCHEMA_TABLE(pTrigger->iDb);
      if( pTrigger->iDb ) code = SQLITE_DROP_TEMP_TRIGGER;
!     if( sqliteAuthCheck(pParse, code, pTrigger->name, pTable->zName, zDb) ||
        sqliteAuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){
        return;
      }
--- 439,445 ----
      const char *zDb = db->aDb[pTrigger->iDb].zName;
      const char *zTab = SCHEMA_TABLE(pTrigger->iDb);
      if( pTrigger->iDb ) code = SQLITE_DROP_TEMP_TRIGGER;
!     if( sqliteAuthCheck(pParse, code, pTrigger->name, pTable->zName, zDb) ||
        sqliteAuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){
        return;
      }
diff -c ../sqlite-2.8.17/src/update.c src/update.c
*** ../sqlite-2.8.17/src/update.c	2005-04-23 18:43:22.000000000 -0400
--- src/update.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 90,96 ****
  
    /* If there are FOR EACH ROW triggers, allocate cursors for the
    ** special OLD and NEW tables
!   */
    if( row_triggers_exist ){
      newIdx = pParse->nTab++;
      oldIdx = pParse->nTab++;
--- 90,96 ----
  
    /* If there are FOR EACH ROW triggers, allocate cursors for the
    ** special OLD and NEW tables
!   */
    if( row_triggers_exist ){
      newIdx = pParse->nTab++;
      oldIdx = pParse->nTab++;
***************
*** 357,363 ****
        sqliteVdbeAddOp(v, OP_MustBeInt, 0, 0);
      }
  
!     /* Compute new data for this record.  
      */
      for(i=0; i<pTab->nCol; i++){
        if( i==pTab->iPKey ){
--- 357,363 ----
        sqliteVdbeAddOp(v, OP_MustBeInt, 0, 0);
      }
  
!     /* Compute new data for this record.  
      */
      for(i=0; i<pTab->nCol; i++){
        if( i==pTab->iPKey ){
diff -c ../sqlite-2.8.17/src/util.c src/util.c
*** ../sqlite-2.8.17/src/util.c	2005-06-06 11:07:03.000000000 -0400
--- src/util.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 185,191 ****
    memcpy(p, oldP, n>oldN ? oldN : n);
    if( n>oldN ){
      memset(&((char*)p)[oldN], 0, n-oldN);
!   }
    memset(oldPi, 0xab, (oldK+N_GUARD+2)*sizeof(int));
    free(oldPi);
  #if MEMORY_DEBUG>1
--- 185,191 ----
    memcpy(p, oldP, n>oldN ? oldN : n);
    if( n>oldN ){
      memset(&((char*)p)[oldN], 0, n-oldN);
!   }
    memset(oldPi, 0xab, (oldK+N_GUARD+2)*sizeof(int));
    free(oldPi);
  #if MEMORY_DEBUG>1
***************
*** 268,274 ****
    if( (p = malloc(n))==0 ){
      if( n>0 ) sqlite_malloc_failed++;
    }
!   return p;
  }
  
  /*
--- 268,274 ----
    if( (p = malloc(n))==0 ){
      if( n>0 ) sqlite_malloc_failed++;
    }
!   return p;
  }
  
  /*
***************
*** 323,329 ****
  }
  #endif /* !defined(MEMORY_DEBUG) */
  
! /*
  ** Create a string from the 2nd and subsequent arguments (up to the
  ** first NULL argument), store the string in memory obtained from
  ** sqliteMalloc() and make the pointer indicated by the 1st argument
--- 323,329 ----
  }
  #endif /* !defined(MEMORY_DEBUG) */
  
! /*
  ** Create a string from the 2nd and subsequent arguments (up to the
  ** first NULL argument), store the string in memory obtained from
  ** sqliteMalloc() and make the pointer indicated by the 1st argument
diff -c ../sqlite-2.8.17/src/vdbe.c src/vdbe.c
*** ../sqlite-2.8.17/src/vdbe.c	2005-04-23 18:43:22.000000000 -0400
--- src/vdbe.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 245,250 ****
--- 245,251 ----
  */
  #define Deephemeralize(P) \
     if( ((P)->flags&MEM_Ephem)!=0 && hardDeephem(P) ){ goto no_mem;}
+ 
  static int hardDeephem(Mem *pStack){
    char *z;
    assert( (pStack->flags & MEM_Ephem)!=0 );
***************
*** 832,838 ****
      assert( pTo->z==pTos->zShort );
      pTo->z = pTo->zShort;
    }
!   pTos--;
    break;
  }
  
--- 833,839 ----
      assert( pTo->z==pTos->zShort );
      pTo->z = pTo->zShort;
    }
!   pTos--;
    break;
  }
  
***************
*** 1671,1677 ****
      if( pOp->opcode==OP_Negative || pTos->r<0.0 ){
        pTos->r = -pTos->r;
      }
!     pTos->flags = MEM_Real;
    }else if( pTos->flags & MEM_Int ){
      Release(pTos);
      if( pOp->opcode==OP_Negative || pTos->i<0 ){
--- 1672,1678 ----
      if( pOp->opcode==OP_Negative || pTos->r<0.0 ){
        pTos->r = -pTos->r;
      }
!     pTos->flags = MEM_Real;
    }else if( pTos->flags & MEM_Int ){
      Release(pTos);
      if( pOp->opcode==OP_Negative || pTos->i<0 ){
***************
*** 2216,2221 ****
--- 2217,2229 ----
  */
  case OP_Commit: {
    int i;
+   if( db->pDeferredFKeys!=0 ){
+     if( sqliteSafetyOff(db) ) goto abort_due_to_misuse; 
+     if( sqliteDoDefDDL(db, &p->zErrMsg)!=0 ){
+       rc = SQLITE_ERROR;
+     }
+     if( sqliteSafetyOn(db) ) goto abort_due_to_misuse;
+   }
    if( db->xCommitCallback!=0 ){
      if( sqliteSafetyOff(db) ) goto abort_due_to_misuse; 
      if( db->xCommitCallback(db->pCommitArg)!=0 ){
***************
*** 2469,2475 ****
    rc = sqliteBtreeFactory(db, 0, 1, TEMP_PAGES, &pCx->pBt);
  
    if( rc==SQLITE_OK ){
!     rc = sqliteBtreeBeginTrans(pCx->pBt);
    }
    if( rc==SQLITE_OK ){
      if( pOp->p2 ){
--- 2477,2483 ----
    rc = sqliteBtreeFactory(db, 0, 1, TEMP_PAGES, &pCx->pBt);
  
    if( rc==SQLITE_OK ){
!     rc = sqliteBtreeBeginTrans(pCx->pBt);
    }
    if( rc==SQLITE_OK ){
      if( pOp->p2 ){
***************
*** 3018,3024 ****
  }
  
  /* Opcode: KeyAsData P1 P2 *
! **
  ** Turn the key-as-data mode for cursor P1 either on (if P2==1) or
  ** off (if P2==0).  In key-as-data mode, the OP_Column opcode pulls
  ** data off of the key rather than the data.  This is used for
--- 3026,3032 ----
  }
  
  /* Opcode: KeyAsData P1 P2 *
! **
  ** Turn the key-as-data mode for cursor P1 either on (if P2==1) or
  ** off (if P2==0).  In key-as-data mode, the OP_Column opcode pulls
  ** data off of the key rather than the data.  This is used for
***************
*** 4299,4305 ****
  **
  ** After the data is stored in the memory location, the
  ** stack is popped once if P2 is 1.  If P2 is zero, then
! ** the original data remains on the stack.
  */
  case OP_MemStore: {
    int i = pOp->p1;
--- 4307,4313 ----
  **
  ** After the data is stored in the memory location, the
  ** stack is popped once if P2 is 1.  If P2 is zero, then
! ** the original data remains on the stack.
  */
  case OP_MemStore: {
    int i = pOp->p1;
***************
*** 4321,4327 ****
--- 4329,4339 ----
      }
      p->aMem = aMem;
      if( nOld<p->nMem ){
+       int j;
        memset(&p->aMem[nOld], 0, sizeof(p->aMem[0])*(p->nMem-nOld));
+       for(j=nOld; j<p->nMem; j++){
+         aMem[j].flags = MEM_Null;
+       }
      }
    }
    Deephemeralize(pTos);
***************
*** 4599,4605 ****
          aMem[i].z = aMem[i].zShort;
        }
      }
!   }
    break;
  }
  
--- 4611,4617 ----
          aMem[i].z = aMem[i].zShort;
        }
      }
!   }
    break;
  }
  
***************
*** 4758,4763 ****
--- 4770,4948 ----
    break;
  }
  
+ /* Opcode: Exec P1 * P3
+ **
+ ** Execute a procedure with name P3. Pop the P1 number of
+ ** parameters of the stack and pass as parameters to the
+ ** procedure.
+ */
+ case OP_Exec: {
+   Vdbe *v = sqliteVdbeCreate(db);
+   Object *pObj;
+   char *pErrMsg = 0;
+ 
+   pObj = sqliteHashFind(&(db->aDb[0].objectHash), pOp->p3, strlen(pOp->p3)+1);
+   pTos -= pOp->p1; /* set pTos to before first parameter */
+   if( pObj && v ){
+ 	  int i;
+ 	  /* set the program code */
+       v->nOpAlloc = -1;
+       v->nOp = pObj->nOp;
+       v->aOp = pObj->aOp;
+ 	  /* move the parameters */
+ 	  v->nMem = pOp->p1+1;
+ 	  v->aMem = sqliteMalloc(v->nMem*sizeof(p->aMem[0]));
+ 	  v->aMem->flags = MEM_Null;
+ 	  for(i=1; i<v->nMem; i++) {
+   		Deephemeralize(&pTos[i]);
+ 	    v->aMem[i] = pTos[i];
+ 	    if( v->aMem[i].flags & MEM_Short ){
+           v->aMem[i].z = v->aMem[i].zShort;
+       }
+ 	  }
+ 	  sqliteVdbeMakeReady(v, 0, 0);
+ 	  sqliteVdbeExec(v);
+ 	  /* check for exceptions */
+     if( v->zErrMsg ) {
+       p->zErrMsg = v->zErrMsg;
+       if( p->errorHandler==0 ) {
+         p->magic = VDBE_MAGIC_HALT;
+         p->pTos = pTos;
+         p->rc = SQLITE_CONSTRAINT;
+         p->errorAction = OE_Abort;
+         return SQLITE_ERROR;
+       }
+       CHECK_FOR_INTERRUPT;
+       pc = p->errorHandler - 1;
+ 	    assert( pTos->flags==MEM_Addr );
+ 	    p->errorHandler = pTos->i;
+ 	    pTos--;
+     }
+ 	  /* fetch the return value */
+ 	  pTos++;
+     *pTos = *(v->aMem); 
+ 	  v->aMem->flags = MEM_Null;
+ 	  Deephemeralize(pTos);
+     if( pTos->flags & MEM_Short ){
+       pTos->z = pTos->zShort;
+ 	  }
+ 	  /* check for exceptions */
+ 	  sqliteVdbeFinalize(v, &pErrMsg);
+   } else {
+     pTos++;
+     pTos->flags = MEM_Null;
+   }
+   break;
+ }
+ 
+ /* Opcode: Raise * * P3
+ **
+ ** Raise eception P3 and jump to the preset exception handler. If P3 is null,
+ ** re-raise the current exception. If no handler was set, return the exception
+ ** to the caller of this Vdbe instance.
+ */
+ case OP_Raise: {
+   if( pOp->p3 ){
+     sqliteSetString(&p->zErrMsg, pOp->p3, 0);
+   } else {
+ 		if( !p->zErrMsg ) {
+ 		  p->zErrMsg = p->zSavedExcep;
+ 		}
+ 		p->zSavedExcep = 0;
+ 	}
+   if( p->errorHandler==0 ) {
+     p->magic = VDBE_MAGIC_HALT;
+     p->pTos = pTos;
+     p->rc = SQLITE_CONSTRAINT;
+     p->errorAction = OE_Abort;
+     return SQLITE_ERROR;
+   }
+   CHECK_FOR_INTERRUPT;
+   pc = p->errorHandler - 1;
+ 	assert( pTos->flags==MEM_Addr );
+ 	p->errorHandler = pTos->i;
+ 	pTos--;
+   break;
+ }
+ 
+ /* Opcode: ExcepWhen P1 P2 P3
+ **
+ ** Check if the current exception is the same as P3 and if so, go to the next
+ ** instruction. Otherwise, jump to the handler at P2. If P2 is 0, return the
+ ** exception to the caller of this Vdbe instance. If P3 is null, match any
+ ** exception. If P1 is non-zero the jump is reversed, i.e. make the jump if
+ ** there is a match.
+ */
+ case OP_ExcepWhen: {
+ 	int match = (pOp->p3==0) || !strcmp(pOp->p3, p->zErrMsg);
+ 
+ 	if( match ) {
+ 		p->zSavedExcep = p->zErrMsg;
+ 		p->zErrMsg = 0;
+ 	}
+ 	if( pOp->p1 ) {
+ 		match = !match;
+ 	}
+   if( !match ) {
+     if( pOp->p2==0 ) {
+       p->magic = VDBE_MAGIC_HALT;
+       p->pTos = pTos;
+       p->rc = SQLITE_CONSTRAINT;
+       p->errorAction = OE_Abort;
+       return SQLITE_ERROR;
+     }
+     CHECK_FOR_INTERRUPT;
+     pc = pOp->p2 - 1;
+   }
+   break;
+ }
+ 
+ /* Opcode: NewHandler * P2 *
+ **
+ ** Set the exception handler to the routines located at address P2. Push
+ ** the previous handler onto the stack.
+ */
+ case OP_NewHandler: {
+ 	pTos++;
+ 	pTos->i = p->errorHandler;
+ 	pTos->flags = MEM_Addr;
+   p->errorHandler = pOp->p2;
+   break;
+ }
+ 
+ /* Opcode: PrevHandler * * *
+ **
+ ** Pop the address of the previous handler of the stack and reinstate it.
+ ** It may reinstate a state with no handler.
+ */
+ case OP_PrevHandler: {
+ 	assert( pTos->flags==MEM_Addr );
+ 	p->errorHandler = pTos->i;
+ 	pTos--;
+   break;
+ }
+ 
+ /* Opcode: Print * * *
+ **
+ ** Print the top of stack to the console. This opcode exists only for
+ ** testing purposes during development. DO NOT USE ANY OTHER WAY.
+ */
+ case OP_Print: {
+   assert( pTos>=p->aStack );
+   if( pTos->flags & MEM_Null ){
+     printf("(null)\n");
+   } else if( pTos->flags & MEM_Int ){
+     printf("%d\n", pTos->i);
+   } else if( pTos->flags & MEM_Real ){
+     printf("%.15g\n", pTos->r);
+   } else {
+     printf("%s\n", pTos->z);
+   }
+   Release(pTos);
+   pTos--;
+   break;
+ }
+ 
  /* An other opcode is illegal...
  */
  default: {
diff -c ../sqlite-2.8.17/src/vdbeInt.h src/vdbeInt.h
*** ../sqlite-2.8.17/src/vdbeInt.h	2005-04-23 18:43:22.000000000 -0400
--- src/vdbeInt.h	2013-06-01 13:15:13.000000000 -0400
***************
*** 130,135 ****
--- 130,136 ----
  #define MEM_Static    0x0020   /* Mem.z points to a static string */
  #define MEM_Ephem     0x0040   /* Mem.z points to an ephemeral string */
  #define MEM_Short     0x0080   /* Mem.z points to Mem.zShort */
+ #define MEM_Addr      0x0100   /* Value is a Vdbe address */
  
  /* The following MEM_ value appears only in AggElem.aMem.s.flag fields.
  ** It indicates that the corresponding AggElem.aMem.z points to a
***************
*** 269,274 ****
--- 270,277 ----
    int rc;                 /* Value to return */
    unsigned uniqueCnt;     /* Used by OP_MakeRecord when P2!=0 */
    int errorAction;        /* Recovery action to do in case of an error */
+ 	int errorHandler;       /* Address of current error handler, 0 if none */
+ 	char *zSavedExcep;      /* Exception that might be re-raised */
    int undoTransOnError;   /* If error, either ROLLBACK or COMMIT */
    int inTempTrans;        /* True if temp database is transactioned */
    int returnStack[100];   /* Return address stack for OP_Gosub & OP_Return */
diff -c ../sqlite-2.8.17/src/vdbeaux.c src/vdbeaux.c
*** ../sqlite-2.8.17/src/vdbeaux.c	2005-04-23 18:43:22.000000000 -0400
--- src/vdbeaux.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 993,1011 ****
      p->pNext->pPrev = p->pPrev;
    }
    p->pPrev = p->pNext = 0;
    if( p->nOpAlloc==0 ){
      p->aOp = 0;
      p->nOp = 0;
    }
-   for(i=0; i<p->nOp; i++){
-     if( p->aOp[i].p3type==P3_DYNAMIC ){
-       sqliteFree(p->aOp[i].p3);
-     }
-   }
    for(i=0; i<p->nVar; i++){
      if( p->abVar[i] ) sqliteFree(p->azVar[i]);
    }
-   sqliteFree(p->aOp);
    sqliteFree(p->aLabel);
    sqliteFree(p->aStack);
    p->magic = VDBE_MAGIC_DEAD;
--- 993,1013 ----
      p->pNext->pPrev = p->pPrev;
    }
    p->pPrev = p->pNext = 0;
+   if( p->nOpAlloc!=-1 ) {
+     for(i=0; i<p->nOp; i++){
+       if( p->aOp[i].p3type==P3_DYNAMIC ){
+         sqliteFree(p->aOp[i].p3);
+ 	  }
+ 	}
+     sqliteFree(p->aOp);
+   }
    if( p->nOpAlloc==0 ){
      p->aOp = 0;
      p->nOp = 0;
    }
    for(i=0; i<p->nVar; i++){
      if( p->abVar[i] ) sqliteFree(p->azVar[i]);
    }
    sqliteFree(p->aLabel);
    sqliteFree(p->aStack);
    p->magic = VDBE_MAGIC_DEAD;
diff -c ../sqlite-2.8.17/src/where.c src/where.c
*** ../sqlite-2.8.17/src/where.c	2005-04-23 18:43:22.000000000 -0400
--- src/where.c	2013-06-01 13:15:13.000000000 -0400
***************
*** 150,156 ****
  static int allowedOp(int op){
    switch( op ){
      case TK_LT:
!     case TK_LE:
      case TK_GT:
      case TK_GE:
      case TK_EQ:
--- 150,156 ----
  static int allowedOp(int op){
    switch( op ){
      case TK_LT:
!     case TK_LE:
      case TK_GT:
      case TK_GE:
      case TK_EQ:
